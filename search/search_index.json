{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Langevin: the <code>lvn</code> software package","text":""},{"location":"#tools-for-integrating-apt-type-langevin-equations","title":"Tools for integrating APT-type Langevin equations.","text":"<p>The  <code>lvn</code> package  provides software tools to help integrate a time-dependent density field described by Langevin equations of absorbing phase transition (APT) type. Directed percolation (DP) is the type-example of such an absorbing phase transition \u2014 its Langevin equation is: $$     \\partial_t\\rho     =     a \\rho     -     b \\rho^2     +     D \\nabla^2 \\rho     +     \\eta\\sqrt{\\rho}\\,\\xi $$ where \\(\\rho(\\mathbf{x},t)\\) is a fluctuating meso-scale field  evolving nonlinearly (with coefficients \\(a\\) and \\(b\\)) subject to diffusion (with rate \\(D\\)) and multiplicative white noise \\(\\sqrt{\\rho}\\,\\xi(\\mathbf{x},t)\\) (with amplitude \\(\\eta\\)).</p> <p>Figure 1: Plot of grid-averaged density \\(\\overline{\\rho}(t)\\) versus time, for an ensemble of simulations with \\(a\\) taking values ranging symmetrically about criticality \\(a_c \\approx 1.8857\\) by up to \\(\\Delta{a}=\\pm 0.01\\):</p> <p>The <code>lvn</code> Langevin integrator employs the operator-splitting method originated largely by Dornic et al (2005). The software tools are implemented as a <code>pip</code>-installable Python package with a C++ core, a set of Jupyter notebooks, and related Python scripts.</p>"},{"location":"cplusplus/","title":"C++ source","text":""},{"location":"cplusplus/#classes","title":"Classes","text":""},{"location":"cplusplus/#files","title":"Files","text":""},{"location":"design/","title":"Design of <code>lvn</code> package","text":"<p>The DP/APT Langevin-equation integrator package is fundamentally a <code>C++</code> code base with Python support modules, all bundled into  a <code>pip</code>-installable package,</p>"},{"location":"design/#c","title":"C++","text":"<p>The <code>C++</code> code base is organized as follows. The code itself can be found here and its Python wrapping is located here; detailed documentation, auto-generated by Doxygen, is available  here. </p>"},{"location":"design/#wrapping","title":"Wrapping","text":"<p>First, there is a wrapper file called <code>cplusplus/dp/wrapper_dplvn.cpp</code> that uses <code>pybind11</code> to link the <code>C++</code> code to a Python runtime.</p> <p>Next, the code is split into a hierarchy of three groups, with files in each group denoted by one of the following prefixes:  (1) <code>langevin_</code>;  (2) <code>dplangevin_</code>;   (3) <code>sim_dplangevin_</code>.</p>"},{"location":"design/#langevin","title":"<code>langevin</code>","text":"<p>The <code>cplusplus/langevin_*</code> source files provide the base <code>BaseLangevin</code> class that implements the operator-splitting integration method in a fairly general fashion. Grid geometry and topology, boundary conditions, initial conditions, the integration scheme, and a general form of the Langevin equation are all coded here. The core Dornic-style integrator is a heavily altered version of the Villa-Mart\u00edn and Buend\u00eda code.</p>"},{"location":"design/#dplangevin","title":"<code>dplangevin</code>","text":"<p>The <code>cplusplus/dp/dplangevin_*</code> files define this <code>DPLangevin</code> integrator class. They inherit the general <code>BaseLangevin</code> integrator class  and implement several methods left undefined by that parent; most important, they define methods implementing the particular functional form of the directed-percolation Langevin equation and its corresponding nonlinear, deterministic integration step in the split operator scheme.</p> <pre><code>   Other types of absorbing-phase transition-type Langevin equation could be\n   implemented with alternate subclasses of [`BaseLangevin`](https://cstarkjp.github.io/Langevin/doxygen/class_base_langevin.html) and alternate \n   versions of the [`SimDP` class](https://cstarkjp.github.io/Langevin/doxygen/class_sim_d_p.html).\n</code></pre>"},{"location":"design/#sim_dplangevin","title":"<code>sim_dplangevin</code>","text":"<p>The <code>cplusplus/dp/sim_dplangevin_*</code> files provide a <code>SimDP</code> class, made available through the wrapper at the Python level, required to manage and execute DP Langevin model integration.  This <code>SimDP</code> class instantiates a <code>DPLangevin</code> class integrator to do the hard work of numerical integration of the stochastic differential equation. Langevin field density grids are returned to Python (via the wrapper) as <code>numpy</code> arrays,    as are time series of the mean density field and its corresponding epochs.</p>"},{"location":"design/#python","title":"Python","text":"<p>The <code>lvn</code> package includes several Python modules to support use of the core <code>C++</code>-based integrator. They are grouped into a set of base modules,  located in the  root Python source folder, and a set of DP-application modules, which can be found in  its <code>dp</code> subfolder.</p> <p>In addition, Python scripts and related Jupyter notebooks are provided to help run DP-type Langevin simulations  (documented here).</p> <p>The main support modules are:</p> <ul> <li>file.py</li> <li>initialize.py</li> <li>serialize.py</li> <li>utils.py</li> <li>viz.py</li> </ul> <p>The DP-specific modules are:</p> <ul> <li>dp/ensemble.py</li> <li>dp/simulation.py</li> <li>dp/vizdp.py</li> </ul>"},{"location":"dp-BatchEnsemble-py-reference/","title":"BatchEnsemble.py","text":"<p>This master Python script batch-executes a set of DP ensemble simulations for a range of grid sizes, ranging from 32 \\(\\times\\) 32 up to 2000 \\(\\times\\) 2000; each ensemble varies the linear DP coefficient \\(a\\) for 15 values over a narrow range around criticality.</p> <p>See: <code>Langevin/Simulation/dp/BatchEnsemble.py</code></p>"},{"location":"dp-Ensemble-ipynb-reference/","title":"Ensemble.ipynb","text":"<p>In this notebook, the linear Langevin coefficient \\(a\\) is varied symmmetrically by a small amount (\\(\\pm 0.01\\)) about the estimated critical value \\(a_c\\) in and ensemble of 15 simulations.</p> <p>See: <code>Langevin/simulation/dp/Ensemble.ipynb</code></p>"},{"location":"dp-Simulation-ipynb-reference/","title":"Simulation.ipynb","text":"<p>This notebook runs a Langevin simulation for a single choice of linear coefficient \\(a\\) and for a single choice of grid size. In constrast to the SimulationDirect.ipynb notebook, here the Python codes is largely abstracted out into lvn.dp.simulation.Simulation.</p> <p>See: <code>Langevin/simulation/dp/Simulation.ipynb</code></p>"},{"location":"dp-SimulationDirect-ipynb-reference/","title":"SimulationDirect.ipynb","text":"<p>This notebook runs a Langevin simulation for a single choice of linear coefficient \\(a\\) and for a single choice of grid size. All the Python code to do this is written directly in the notebook.</p> <p>See: <code>Langevin/Simulation/dp/SimulationDirect.ipynb</code></p>"},{"location":"ensemble-reference/","title":"ensemble.py","text":""},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble","title":"Ensemble","text":"<pre><code>Ensemble(info_path: Sequence[str], do_verbose: bool = False)\n</code></pre> <p>Multiprocessing wrapper class to batch run Langevin integrations.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>create</code>             \u2013              <p>Generate list of <code>Simulation</code> instances.</p> </li> <li> <code>exec</code>             \u2013              <p>Execute an ensemble of sims in parallel using <code>multiprocessing</code>.</p> </li> <li> <code>exec_multiple_sims</code>             \u2013              <p>Carry out the <code>multiprocessing</code> parallelization of the ensemble of sims.</p> </li> <li> <code>initialize</code>             \u2013              <p>Carry out initialization of each </p> </li> <li> <code>multi_plot</code>             \u2013              <p>Generate graphs of the ensemble results.</p> </li> <li> <code>plot</code>             \u2013              <p>Generate graphs for results from a single sim.</p> </li> <li> <code>save</code>             \u2013              <p>Export Outfo.json, graphs, and data files.</p> </li> <li> <code>sim_exec_wrapper</code>             \u2013              <p>Pool wrapper to execute a specific sim instance.</p> </li> </ul> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def __init__(\n        self, info_path: Sequence[str], do_verbose: bool=False,\n    ) -&gt; None:\n    \"\"\"\n    Constructor.\n\n    Args:\n        info_path: \n            file path to `Info.json` broken up into tuple/list of strings\n        do_verbose: \n            flag whether to use `tqdm` progress bar, and report operations\n    \"\"\"\n    self.info: dict\n    _, self.info = read_info(info_path, dplvn)\n    self.info[\"Misc\"][\"path\"] = info_path\n    self.do_verbose =  do_verbose\n    if do_verbose:\n        print(f\"Ensemble results path:  {self.info[\"Misc\"][\"path\"]}\")\n\n    # n_max_cores: int = self.misc[\"n_max_cores\"]\n    n_cores: int = cpu_count()\n    self.info[\"Misc\"][\"n_cores\"] = n_cores\n    n_sims: int = self.info[\"Misc\"][\"n_sims\"]\n    n_subcritical: int = (n_sims//2)\n    n_supercritical: int = n_sims - n_subcritical\n    \u0394a: float = self.info[\"Misc\"][\"\u0394a_range\"]/n_subcritical\n    a_c: float = self.info[\"Analysis\"][\"a_c\"]\n    n_round: int = self.info[\"Misc\"][\"n_digits\"]\n\n    a_list: list[float] = list(filter(lambda a: a&gt;=0, (\n        [round(a_c-\u0394a*i_, n_round) for i_ in range(n_subcritical, 0, -1)]\n        +\n        [round(a_c+\u0394a*i_, n_round) for i_ in range(0, n_supercritical)]\n    )))[::-1]\n    b_list: list[float] = [self.info[\"Parameters\"][\"quadratic\"]]*n_sims\n    seed_list: list[int] = [\n        self.info[\"Parameters\"][\"random_seed\"]*(i_+1) \n        for i_ in range(n_sims)\n    ]\n    assert n_sims==len(a_list)\n\n    self.info_list: list[dict] = [\n        deepcopy(self.info) for _ in range(n_sims)\n    ]\n    for (info_, a_, b_,seed_) in zip(\n        self.info_list, a_list, b_list, seed_list,\n    ):\n        info_[\"Parameters\"][\"linear\"] = a_\n        info_[\"Parameters\"][\"quadratic\"] = b_\n        info_[\"Parameters\"][\"random_seed\"] = seed_\n    if self.do_verbose:\n        print(f\"a: {[round(a_,5) for a_ in a_list]}\")\n        print(f\"b: {[round(b_,5) for b_ in b_list]}\")\n        print(f\"seeds: {[seed_ for seed_ in seed_list]}\")\n\n    self.graphs: VizDP\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble(info_path)","title":"<code>info_path</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>file path to <code>Info.json</code> broken up into tuple/list of strings</p>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble(do_verbose)","title":"<code>do_verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>flag whether to use <code>tqdm</code> progress bar, and report operations</p>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.create","title":"create","text":"<pre><code>create() -&gt; None\n</code></pre> <p>Generate list of <code>Simulation</code> instances.</p> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def create(self) -&gt; None:\n    \"\"\"\n    Generate list of [`Simulation`][lvn.dp.simulation.Simulation] instances.\n    \"\"\"\n    self.sim_list: list[Simulation] = []\n    sim_: Simulation\n    keys: Sequence[str] = (\n        \"linear\", \"quadratic\", \"diffusion\", \"noise\", \"random_seed\",\n    )\n    for key_ in keys:\n        self.info[\"Parameters\"][key_+\"_list\"] = []\n        del self.info[\"Parameters\"][key_]\n    n_sims: int = self.info[\"Misc\"][\"n_sims\"]\n    n_cores: int = self.info[\"Misc\"][\"n_cores\"]\n    for i_, info_ in enumerate(self.info_list):\n        # Progress bar only for the last in each n_core batch\n        do_verbose_: bool = (\n            self.do_verbose \n            if i_%n_cores==0\n            # if i_%n_cores==n_cores-1 or i_==n_sims-1\n            else False\n        )\n        sim_ = \\\n            Simulation(\n                name=None,\n                path=info_[\"Misc\"][\"path\"], \n                # Don't send a reference to the source info!\n                info=deepcopy(info_), \n                do_verbose=do_verbose_,\n            )\n        self.sim_list += [sim_]\n        if self.do_verbose:\n            print(f\"Simulation#{i_+1} path:  {sim_.misc[\"path\"]}\")\n        for key_ in keys:\n            self.info[\"Parameters\"][key_+\"_list\"] +=[sim_.parameters[key_]]\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.exec","title":"exec","text":"<pre><code>exec() -&gt; None\n</code></pre> <p>Execute an ensemble of sims in parallel using <code>multiprocessing</code>.</p> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def exec(self) -&gt; None:\n    \"\"\"\n    Execute an ensemble of sims in parallel using `multiprocessing`.\n    \"\"\"\n    ensemble_results: list[Sequence[tuple]] \\\n        = self.exec_multiple_sims(self.sim_exec_wrapper)\n    for (sim_results_, sim_,) in zip(ensemble_results, self.sim_list):\n        sim_.t_epochs = np.array(sim_results_[0])\n        sim_.mean_densities = np.array(sim_results_[1])\n        sim_.misc[\"computation_time\"] = sim_results_[2]\n        self.info[\"Misc\"][\"computation_time\"] = sim_results_[2]\n    self.info[\"Misc\"][\"dplvn_version\"] \\\n        = self.sim_list[0].misc[\"dplvn_version\"]\n    self.info[\"Misc\"][\"date_time\"] \\\n        = self.sim_list[0].misc[\"date_time\"]\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.exec_multiple_sims","title":"exec_multiple_sims","text":"<pre><code>exec_multiple_sims(function: Callable) -&gt; list[Sequence[tuple]]\n</code></pre> <p>Carry out the <code>multiprocessing</code> parallelization of the ensemble of sims.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Sequence[tuple]]</code>           \u2013            <p>list of serialized outputs returned by each completed sim.</p> </li> </ul> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def exec_multiple_sims(self, function: Callable,) -&gt; list[Sequence[tuple]]:\n    \"\"\"\n    Carry out the `multiprocessing` parallelization of the ensemble of sims.\n\n    Args:\n        function: wrapper passed to pool to act on each sim instance.\n\n    Returns:\n        list of serialized outputs returned by each completed sim.\n    \"\"\"\n    ensemble_results: list[Sequence[tuple]]\n    with Pool(processes=self.info[\"Misc\"][\"n_cores\"]) as pool:\n        ensemble_results = (pool.map(function, self.sim_list,))\n    return ensemble_results\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.exec_multiple_sims(function)","title":"<code>function</code>","text":"(<code>Callable</code>)           \u2013            <p>wrapper passed to pool to act on each sim instance.</p>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; None\n</code></pre> <p>Carry out initialization of each  <code>Simulation</code> instance.</p> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Carry out initialization of each \n    [`Simulation`][lvn.dp.simulation.Simulation] instance.\n    \"\"\"\n    for sim_ in self.sim_list:\n        sim_.initialize()\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.multi_plot","title":"multi_plot","text":"<pre><code>multi_plot() -&gt; None\n</code></pre> <p>Generate graphs of the ensemble results.</p> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def multi_plot(self) -&gt; None:\n    \"\"\"\n    Generate graphs of the ensemble results.\n    \"\"\"\n    if not hasattr(self, \"graphs\"):\n        self.graphs = VizDP()\n    self.graphs.multiplot_mean_density_evolution(\n        \"\u03c1_t_loglog\",\n        self.info, self.sim_list,\n        do_rescale=False, y_sf=0.75,\n    )\n    self.graphs.multiplot_mean_density_evolution(\n        \"\u03c1_t_rescaled\",\n        self.info, self.sim_list,\n        do_rescale=True,\n    )\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.plot","title":"plot","text":"<pre><code>plot() -&gt; None\n</code></pre> <p>Generate graphs for results from a single sim.</p> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def plot(self) -&gt; None:\n    \"\"\"\n    Generate graphs for results from a single sim.\n    \"\"\"\n    for sim_ in self.sim_list:\n        sim_.plot()\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.save","title":"save","text":"<pre><code>save(module: Any, do_dummy: bool = False) -&gt; None\n</code></pre> <p>Export Outfo.json, graphs, and data files.</p> <p>Parameters:</p> <p>Depending on Info.json settings, output also may be carried out  for all simulations into separate folders.</p> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>def save(self, module: Any, do_dummy: bool=False,) -&gt; None:\n    \"\"\"\n    Export Outfo.json, graphs, and data files.\n\n    Args:\n        do_dummy: only create &amp; report anticipated output folders.\n\n    Depending on Info.json settings, output also may be carried out \n    for all simulations into separate folders.\n    \"\"\"\n    outfo_path: str = \\\n        create_directories(\n            (os.path.pardir, *self.info[\"Misc\"][\"path\"]), \"\"\n        )\n    if self.do_verbose:\n        print(f\"experiments outfo path:  {outfo_path}\")\n    if not do_dummy:\n        _ = export_info(outfo_path, \"Outfo\", self.info, module,)\n\n    graphs_path: str = \\\n        create_directories(\n            (os.path.pardir, *self.info[\"Misc\"][\"path\"]), \"\",\n        )\n    if self.do_verbose:\n        print(f\"Combo graph path:  {graphs_path}\")\n    if self.info[\"Misc\"][\"do_export_combo_graphs\"] and not do_dummy:\n        _ = export_plots(\n            self.graphs.fdict, \n            graphs_path,\n            do_verbose=False,\n        )\n\n    data_path: str = \\\n        create_directories(\n            (os.path.pardir, *self.info[\"Misc\"][\"path\"]), \"\",\n        )\n    if self.do_verbose:\n        print(f\"Combo data path:  {outfo_path}\")\n    if self.info[\"Misc\"][\"do_export_combo_data\"]:\n        t_epochs: NDArray = self.sim_list[0].t_epochs\n        mean_densities: NDArray = np.array([\n            sim_.mean_densities for sim_ in self.sim_list\n        ])\n    if not do_dummy:\n        np.savez_compressed(\n            os.path.join(data_path, \"combo_\u03c1_t\",), \n            t_epochs=t_epochs,\n            mean_densities=mean_densities,\n        )\n\n    if self.info[\"Misc\"][\"do_export_data\"]:\n        for (i_, sim_) in enumerate(self.sim_list):\n            sim_.save(dplvn, do_dummy, do_verbose=True,)\n</code></pre>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.save(do_dummy)","title":"<code>do_dummy</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only create &amp; report anticipated output folders.</p>"},{"location":"ensemble-reference/#lvn.dp.ensemble.Ensemble.sim_exec_wrapper","title":"sim_exec_wrapper  <code>staticmethod</code>","text":"<pre><code>sim_exec_wrapper(sim: Simulation) -&gt; Sequence[tuple]\n</code></pre> <p>Pool wrapper to execute a specific sim instance.</p> <p>Returns:</p> <ul> <li> <code>Sequence[tuple]</code>           \u2013            <p>serialized output returned by the completed sim.</p> </li> </ul> Source code in <code>lvn/dp/ensemble.py</code> <pre><code>@staticmethod\ndef sim_exec_wrapper(sim: Simulation) -&gt; Sequence[tuple]:\n    \"\"\"\n    Pool wrapper to execute a specific sim instance.\n\n    Returns:\n        serialized output returned by the completed sim.\n    \"\"\"\n    return sim.exec()\n</code></pre>"},{"location":"file-reference/","title":"file.py","text":""},{"location":"file-reference/#lvn.file.create_dir","title":"create_dir","text":"<pre><code>create_dir(dir: str) -&gt; str\n</code></pre> <p>Try to create an output directory if one doesn't exist.</p> <p>Throws an exception if the directory cannot be created. Returns quietly if the directory already exists.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>path to directory (see :mod:<code>os.path</code>)</p> </li> </ul> Source code in <code>lvn/file.py</code> <pre><code>def create_dir(dir: str) -&gt; str:\n    \"\"\"\n    Try to create an output directory if one doesn't exist.\n\n    Throws an exception if the directory cannot be created.\n    Returns quietly if the directory already exists.\n\n    Args:\n        dir: \n            name of directory\n\n    Returns:\n        path to directory (see :mod:`os.path`)\n    \"\"\"\n    try:\n        if not exists(dir):\n            mkdir(dir)\n        else:\n            return dir\n    except OSError:\n        print(f'Cannot create directory \"{realpath(dir)}\"')\n        raise\n    except Exception:\n        print(Exception)\n        raise\n    return dir\n</code></pre>"},{"location":"file-reference/#lvn.file.create_dir(dir)","title":"<code>dir</code>","text":"(<code>str</code>)           \u2013            <p>name of directory</p>"},{"location":"file-reference/#lvn.file.create_directories","title":"create_directories","text":"<pre><code>create_directories(\n    results_path: Sequence = (\"..\", \"experiments\"),\n    results_dir: str = \"Demo\",\n    do_clean: bool = False,\n) -&gt; str\n</code></pre> <p>Create results parent and target directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>path to target results directory (see :mod:<code>os.path</code>)</p> </li> </ul> Source code in <code>lvn/file.py</code> <pre><code>def create_directories(\n        results_path: Sequence = (\"..\", \"experiments\",), \n        results_dir: str = \"Demo\",\n        do_clean: bool=False,\n    ) -&gt; str:\n    \"\"\"\n    Create results parent and target directory.\n\n    Args:\n        results_path: path to parent results directory\n            (to be created if necessary)\n        results_dir: target results directory (to be created)\n\n    Returns:\n        path to target results directory (see :mod:`os.path`)\n    \"\"\"\n    results_path_ = [\".\"] + list(results_path)\n    create_dir(join(*results_path_))\n    results_dir_ = results_path_ + [results_dir]\n    if do_clean and exists(join(*results_dir_)):\n        rmtree(join(*results_dir_))\n    return create_dir(join(*results_dir_))\n</code></pre>"},{"location":"file-reference/#lvn.file.create_directories(results_path)","title":"<code>results_path</code>","text":"(<code>Sequence</code>, default:                   <code>('..', 'experiments')</code> )           \u2013            <p>path to parent results directory (to be created if necessary)</p>"},{"location":"file-reference/#lvn.file.create_directories(results_dir)","title":"<code>results_dir</code>","text":"(<code>str</code>, default:                   <code>'Demo'</code> )           \u2013            <p>target results directory (to be created)</p>"},{"location":"file-reference/#lvn.file.export_info","title":"export_info","text":"<pre><code>export_info(\n    info_dir: str,\n    file_name: str,\n    source_dict: dict,\n    module: Any,\n    suffix: str | None = None,\n    encoding: str = \"utf-8\",\n) -&gt; tuple[dict, str]\n</code></pre> <p>Export results dictionary to JSON file.</p> <p>Tries to ensure all dictionary entries are serializable by running <code>latex</code> on keys and converting values to floats.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[dict, str]</code>           \u2013            <p>serialized dictionary and the file path string</p> </li> </ul> Source code in <code>lvn/file.py</code> <pre><code>def export_info(\n        info_dir: str, \n        file_name: str, \n        source_dict: dict, \n        module: Any,\n        suffix: str | None = None,\n        encoding: str = \"utf-8\", #\"latin-1\"\n    ) -&gt; tuple[dict, str]:\n    \"\"\"\n    Export results dictionary to JSON file.\n\n    Tries to ensure all dictionary entries are\n    serializable by running `latex`\n    on keys and converting values to floats.\n\n    Args:\n        info_dir: target parent folder\n        file_name: name of output JSON file\n        module: dplvn or other class module\n        source_dict: dictionary of results, possibly requiring conversion\n            from latex form such that serialization into a JSON file\n            is possible\n        suffix: to append to filename prior to addition of '.json' extension\n\n    Returns:\n        serialized dictionary and the file path string\n    \"\"\"\n    # A bit of recursion for a change\n    def render_serializable(source, module,) -&gt; dict:\n        serialized: dict = {}\n        for item_ in source.items():\n            if type(item_[1]) is dict:\n                serialized.update(\n                    {item_[0]: render_serializable(item_[1], module,)}\n                )\n            else:\n                serialized.update(\n                    {item_[0]: to_serializable(item_[1], module,)}\n                )\n        return serialized\n\n    serializable_dict: dict = render_serializable(source_dict, module,)\n    info_path = [str(info_dir)] + [\n        str(file_name) + (\"_\"+suffix if suffix is not None else \"\") + \".json\"\n    ]\n\n    file: TextIOWrapper\n    with open(join(*info_path), \"w\", encoding=encoding) as file:\n        logging.info(join(*info_path))\n        dump(serializable_dict, file, indent=4, ensure_ascii=False,) #separators=(\", \\n\", \": \")\n    return (serializable_dict, info_dir,)\n</code></pre>"},{"location":"file-reference/#lvn.file.export_info(info_dir)","title":"<code>info_dir</code>","text":"(<code>str</code>)           \u2013            <p>target parent folder</p>"},{"location":"file-reference/#lvn.file.export_info(file_name)","title":"<code>file_name</code>","text":"(<code>str</code>)           \u2013            <p>name of output JSON file</p>"},{"location":"file-reference/#lvn.file.export_info(module)","title":"<code>module</code>","text":"(<code>Any</code>)           \u2013            <p>dplvn or other class module</p>"},{"location":"file-reference/#lvn.file.export_info(source_dict)","title":"<code>source_dict</code>","text":"(<code>dict</code>)           \u2013            <p>dictionary of results, possibly requiring conversion from latex form such that serialization into a JSON file is possible</p>"},{"location":"file-reference/#lvn.file.export_info(suffix)","title":"<code>suffix</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>to append to filename prior to addition of '.json' extension</p>"},{"location":"file-reference/#lvn.file.export_plot","title":"export_plot","text":"<pre><code>export_plot(\n    fig_name: str,\n    fig: Any,\n    results_dir: str,\n    file_type: str = \"pdf\",\n    suffix: str = \"\",\n    dpi: int | None = None,\n) -&gt; None\n</code></pre> <p>Export plot to PDF or other format file.</p> <p>Parameters:</p> Source code in <code>lvn/file.py</code> <pre><code>def export_plot(\n        fig_name: str,\n        fig: Any,\n        results_dir: str,\n        file_type: str = \"pdf\", \n        suffix: str = \"\",\n        dpi: int | None = None,\n    ) -&gt; None:\n    \"\"\"\n    Export plot to PDF or other format file.\n\n    Args:\n        fig_name: name to be used for file (extension auto-appended)\n        fig: figure object\n        results_dir: name of output directory\n        file_type: file format\n        suffix: filename suffix\n        dpi: output image resolution\n    \"\"\"\n    fig_name_ = f\"{fig_name}{suffix}.{file_type.lower()}\"\n    # print(f\"{fig_name_} exists: {exists(join(results_dir, fig_name_))}\")\n    try:\n        # logging.info(f'dpi={dpi}')\n        fig.savefig(\n            join(results_dir, fig_name_),\n            bbox_inches=\"tight\",\n            pad_inches=0.05,\n            dpi=dpi,\n            format=file_type,\n        )\n        logging.info(f'export_plot: Exported \"{fig_name_}\"')\n    except OSError:\n        logging.info(\n            f'export_plot: Failed to export figure \"{fig_name_}\"'\n        )\n        raise\n    except:\n        raise\n</code></pre>"},{"location":"file-reference/#lvn.file.export_plot(fig_name)","title":"<code>fig_name</code>","text":"(<code>str</code>)           \u2013            <p>name to be used for file (extension auto-appended)</p>"},{"location":"file-reference/#lvn.file.export_plot(fig)","title":"<code>fig</code>","text":"(<code>Any</code>)           \u2013            <p>figure object</p>"},{"location":"file-reference/#lvn.file.export_plot(results_dir)","title":"<code>results_dir</code>","text":"(<code>str</code>)           \u2013            <p>name of output directory</p>"},{"location":"file-reference/#lvn.file.export_plot(file_type)","title":"<code>file_type</code>","text":"(<code>str</code>, default:                   <code>'pdf'</code> )           \u2013            <p>file format</p>"},{"location":"file-reference/#lvn.file.export_plot(suffix)","title":"<code>suffix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>filename suffix</p>"},{"location":"file-reference/#lvn.file.export_plot(dpi)","title":"<code>dpi</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>output image resolution</p>"},{"location":"file-reference/#lvn.file.export_plots","title":"export_plots","text":"<pre><code>export_plots(\n    fig_dict: dict,\n    results_dir: str,\n    file_types: list[str] | tuple[str] | str = \"png\",\n    suffix: str = \"\",\n    dpi: int = 150,\n    do_verbose: bool = False,\n) -&gt; str\n</code></pre> <p>Export plots to PDF or other format files.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>the supplied export directory</p> </li> </ul> Source code in <code>lvn/file.py</code> <pre><code>def export_plots(\n        fig_dict: dict,\n        results_dir: str,\n        file_types: list[str] | tuple[str] | str = \"png\",\n        suffix: str = \"\",\n        dpi: int = 150,\n        do_verbose: bool=False,\n    ) -&gt; str:\n    \"\"\"\n    Export plots to PDF or other format files.\n\n    Args:\n        fig_dict: dictionary of figures\n        results_dir: name of output directory\n        file_types: file format (or list of file formats)\n        suffix: filename suffix\n        dpi: output image resolution\n        do_verbose: use tqdm progress bar to track \n\n    Returns:\n        the supplied export directory\n    \"\"\"\n    results_path: str = realpath(results_dir)\n    logging.info(\n        \"gmplib.save.export_plots:\\n   \" + f'Writing to dir: \"{results_path}\"'\n    )\n    file_types_: List[str] = (\n        file_types if isinstance(file_types, list) else [str(file_types)]\n    )\n    progress_bar: Callable = (\n        progress if do_verbose else progress_disabled\n    )\n    for file_type in file_types_:\n        # logging.info(f'Image file type: \"{file_type}\"')\n        for fig_name, fig in progress_bar(fig_dict.items(),):\n            export_plot(\n                fig_name, fig,\n                results_path,\n                file_type=file_type,\n                suffix=suffix,\n                dpi=dpi,\n            )\n    return results_dir\n</code></pre>"},{"location":"file-reference/#lvn.file.export_plots(fig_dict)","title":"<code>fig_dict</code>","text":"(<code>dict</code>)           \u2013            <p>dictionary of figures</p>"},{"location":"file-reference/#lvn.file.export_plots(results_dir)","title":"<code>results_dir</code>","text":"(<code>str</code>)           \u2013            <p>name of output directory</p>"},{"location":"file-reference/#lvn.file.export_plots(file_types)","title":"<code>file_types</code>","text":"(<code>list[str] | tuple[str] | str</code>, default:                   <code>'png'</code> )           \u2013            <p>file format (or list of file formats)</p>"},{"location":"file-reference/#lvn.file.export_plots(suffix)","title":"<code>suffix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>filename suffix</p>"},{"location":"file-reference/#lvn.file.export_plots(dpi)","title":"<code>dpi</code>","text":"(<code>int</code>, default:                   <code>150</code> )           \u2013            <p>output image resolution</p>"},{"location":"file-reference/#lvn.file.export_plots(do_verbose)","title":"<code>do_verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>use tqdm progress bar to track </p>"},{"location":"file-reference/#lvn.file.import_info","title":"import_info","text":"<pre><code>import_info(info_dir: str, file_name: str, module: Any) -&gt; dict\n</code></pre> <p>Read and adapt parameters specified in a JSON file.</p> <p>Parameters:</p> <p>Returns: info as dictionary.</p> Source code in <code>lvn/file.py</code> <pre><code>def import_info(\n        info_dir: str, \n        file_name: str,\n        module: Any,\n    ) -&gt; dict:\n    \"\"\"\n    Read and adapt parameters specified in a JSON file.\n\n    Args:\n        info_dir: parent folder of JSON file\n        file_name:  JSON file name.\n        module: dplvn or other class module\n\n    Returns: info as dictionary.\n    \"\"\"\n    file: TextIOWrapper\n    raw_info: dict\n    info_path = [str(info_dir)] + [f\"{file_name}.json\"]\n    with open(join(*info_path), \"r\",) as file:\n        raw_info = load(file)\n    parameters: dict = {}\n    for item_ in raw_info[\"Parameters\"].items():\n        parameters.update({item_[0]: from_serializable(item_[1], module)})\n    info: dict = {\n        \"Analysis\": raw_info[\"Analysis\"],\n        \"Parameters\": parameters,\n        \"Misc\":  raw_info[\"Misc\"]\n    }\n    return info\n</code></pre>"},{"location":"file-reference/#lvn.file.import_info(info_dir)","title":"<code>info_dir</code>","text":"(<code>str</code>)           \u2013            <p>parent folder of JSON file</p>"},{"location":"file-reference/#lvn.file.import_info(file_name)","title":"<code>file_name</code>","text":"(<code>str</code>)           \u2013            <p>JSON file name.</p>"},{"location":"file-reference/#lvn.file.import_info(module)","title":"<code>module</code>","text":"(<code>Any</code>)           \u2013            <p>dplvn or other class module</p>"},{"location":"file-reference/#lvn.file.read_info","title":"read_info","text":"<pre><code>read_info(path: Sequence[str], module: Any) -&gt; tuple[str, dict]\n</code></pre> <p>Wrapper around method to import info dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[str, dict]</code>           \u2013            <p>path to file and imported dictionary</p> </li> </ul> Source code in <code>lvn/file.py</code> <pre><code>def read_info(\n        path: Sequence[str],\n        module: Any,\n    ) -&gt; tuple[str, dict]:\n    \"\"\"\n    Wrapper around method to import info dictionary.\n\n    Args:\n        path: to info JSON file.\n        module: dplvn or other class module\n\n    Returns:\n        path to file and imported dictionary\n    \"\"\"\n    full_path: str = join(pardir, *path,)\n    info: dict = import_info(full_path, \"Info\", module,)\n    return (full_path, info,)\n</code></pre>"},{"location":"file-reference/#lvn.file.read_info(path)","title":"<code>path</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>to info JSON file.</p>"},{"location":"file-reference/#lvn.file.read_info(module)","title":"<code>module</code>","text":"(<code>Any</code>)           \u2013            <p>dplvn or other class module</p>"},{"location":"how-to-install/","title":"How to install","text":"<ol> <li> <p>Install Python \\(\\geq\\) 3.12 and the following packages, ideally in a Python environment:</p> <ul> <li><code>numpy</code></li> <li><code>jupyter</code></li> <li><code>ipython</code></li> <li><code>matplotlib</code> </li> <li><code>pandas</code></li> <li><code>tqdm</code></li> <li><code>ffmpeg-python</code></li> </ul> </li> <li> <p>Install the Python library <code>lvn</code> using <code>pip</code>, hopefully within a Python environment, from TestPyPI:</p> <pre><code>pip install -i https://test.pypi.org/simple/ lvn\n</code></pre> <p>If you already have a pre-existing installation of this package, you may need to <code>upgrade</code> (update) to the latest version:</p> <pre><code>pip install -i https://test.pypi.org/simple/ lvn --upgrade\n</code></pre> </li> <li> <p>Clone the Langevin repo to your local machine:</p> <pre><code>git clone https://github.com/cstarkjp/Langevin.git\n</code></pre> <p>which will create a <code>Langevin/</code> folder. </p> <p>If you already have a local copy of the repo, update it with <code>git pull</code>, making sure you are on the <code>main</code> branch (do <code>git checkout main</code>).</p> </li> </ol>"},{"location":"how-to-run/","title":"How to run","text":"<ol> <li> <p>Navigate to <code>Langevin/simulation/dp/</code>. There you'll find Jupyter notebooks and Python scripts to run DP-type Langevin simulations.</p> </li> <li> <p>Don't run the noteboooks in-situ: their output will be written to <code>Langevin/experiments/</code> which will generate <code>git</code> conflicts. </p> <p>Instead, make your own folder elsewhere (e.g., <code>MyDPLangevin/</code> ), outside of the cloned <code>lvn.dp</code> file hierarchy, and copy <code>Langevin/simulation/</code> into it.</p> </li> <li> <p>Do the same for the folder <code>Langevin/experiments/</code>, copying it into e.g. <code>MyDPLangevin/</code>. </p> <p>The <code>Langevin/experiments/</code> folder has subfolders containing <code>Info.json</code> files, each named to refer logically to the model being run; these JSON files are used to drive the Langevin model simulations. </p> </li> <li> <p>Navigate to your <code>MyDPLangevin/simulation/</code> folder and run e.g. <code>Simulation.ipynb</code>. With this notebook, you can carry out a single integration of the DP Langevin equation. </p> <p>Depending on the name assigned to <code>sim_name</code> in this notebook (which specifies a model subfolder in <code>experiments/</code>), the appropriate <code>Info.json</code> file is parsed for model parameters, a single Langevin integration is performed, and output data files are written to that <code>experiments/</code> subfolder.</p> <p>For example, if <code>sim_name = a1p18855_b1_D0p04_\u03b71_x31_y31_\u0394x1_\u0394t0p1</code>, the <code>Info.json</code> file in <code>experiments/a1p18855_b1_D0p04_\u03b71_x31_y31_\u0394x1_\u0394t0p1/</code> is used to drive the simulation, and output files are written to this folder.</p> </li> </ol>"},{"location":"info-reference/","title":"Example <code>Info.json</code> file","text":"<p>JSON-format files (essentially Python dictionaries) are used to drive the DP Langevin simulations. Here is one example, taken from <code>Langevin/experiments/a1p18855_b1_D0p04_\u03b71_x125_y125_\u0394x1_\u0394t0p1/Info.json</code>:</p> <pre><code>{\n    \"Parameters\": {\n        \"linear\": 1.18855,\n        \"quadratic\": 1,\n        \"diffusion\": 0.04,\n        \"noise\": 1,\n        \"dx\": 1,\n        \"dt\": 0.1,\n        \"t_final\": 10000.0,\n        \"random_seed\": 1,\n        \"grid_dimension\": \"D2\",\n        \"grid_size\": [125, 125],\n        \"grid_topologies\": [\"BOUNDED\", \"BOUNDED\"],\n        \"boundary_conditions\": [\"FLOATING\",\"FLOATING\",\"FLOATING\",\"FLOATING\"],\n        \"initial_condition\": \"RANDOM_UNIFORM\",\n        \"ic_values\": [0, 10],\n        \"integration_method\": \"RUNGE_KUTTA\"\n    },\n    \"Analysis\": {\n        \"a_c\": 1.18857\n    },\n    \"Misc\": {\n        \"n_sims\": 15,\n        \"\u0394a_range\": 0.01,\n        \"n_round_\u0394t_summation\": 5,\n        \"n_segments\": 500,\n        \"n_digits\": 6,\n        \"do_export_combo_graphs\": false,\n        \"do_export_combo_data\": false,\n        \"do_export_graphs\": true,\n        \"do_export_data\": true,\n        \"do_export_images\": true,\n        \"do_make_video\": true,\n        \"ylimits_log\": [5e-4, 2e0],\n        \"xlimits_log\": [5e-1, 1.2e4],\n        \"ylimits_rescaled\": [3e-2, 1e1],\n        \"xlimits_rescaled\": [5e-5, 2e3],\n        \"video_frame_rate\": 50,\n        \"video_format\": \"mp4\"\n    }\n}\n</code></pre>"},{"location":"initialize-reference/","title":"initialize.py","text":""},{"location":"initialize-reference/#lvn.initialize","title":"initialize","text":"<p>Configure to run in <code>IPython</code>_.</p> <p>Sets up <code>IPython</code> environment if we're running in a <code>Jupyter notebook</code> or <code>Jupyter QtConsole</code>_.</p> <ul> <li>prepares Matplotlib to display inline and (for Macs)    at a 'retina' resolution -- if this    is not available, a benign error report (currently disabled)    is made and progress continues</li> <li>enables automatic reloading (in case the code has been modded)     when a notebook is re-run in-situ</li> </ul> <p>Requires <code>Matplotlib</code> and <code>IPython</code>.</p> <p>Uses IPython extensions <code>autoreload</code>_.</p> <p>The  <code>autoreload</code>_ extension forces the parent package to be reloaded on restart. This makes code modding and subsequent rerunning of a notebook smooth and seamless. It is not needed for normal operation, and if unavailable processing continues regardless.</p> <p>.. _Matplotlib: https://matplotlib.org/ .. _autoreload:     https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html .. _IPython: https://ipython.readthedocs.io/en/stable/ .. _Jupyter notebook: https://jupyter-notebook.readthedocs.io/en/stable/ .. _Jupyter QtConsole: https://qtconsole.readthedocs.io/en/stable/</p> <p>Functions:</p> <ul> <li> <code>check_is_ipython</code>             \u2013              <p>Check if we are running an IPython kernel from Jupyter etc.</p> </li> </ul>"},{"location":"initialize-reference/#lvn.initialize.check_is_ipython","title":"check_is_ipython","text":"<pre><code>check_is_ipython() -&gt; bool\n</code></pre> <p>Check if we are running an IPython kernel from Jupyter etc.</p> Source code in <code>lvn/initialize.py</code> <pre><code>def check_is_ipython() -&gt; bool:\n    \"\"\"Check if we are running an IPython kernel from Jupyter etc.\"\"\"\n    try:\n        if \"IPKernelApp\" not in get_ipython().config:   #type: ignore\n            return False\n    except ImportError:\n        return False\n    except AttributeError:\n        return False\n    return True\n</code></pre>"},{"location":"navigation/","title":"Navigation","text":"<p>The structure of this software package is outlined here or via the \"Software design\" sidebar menu item.</p> <p>Installation notes are available here or via the \"How to install\" menu item.</p> <p>Rough notes on how to run simulations are available here or via the \"How to run\" menu item. </p> <p>Simple test scripts are provided under <code>Tests</code> via in the sidebar/menu .</p> <p>Head to the links under \"Simulation tools\" for more complete examples. </p> <p>The key driver of a simulation is the <code>Info.json</code> file; care must be taken to match their implied \"job name\" with their parent folder name.</p> <p>Refer to the links under \"Python modules\" to see documentation of the <code>lvn</code> Python package. The underlying <code>C++</code> core is documented under \"C++ source\" using <code>Doxygen</code>.</p>"},{"location":"references/","title":"References","text":"<ul> <li> <p>Buend\u00eda, 2019: \"Dornic integration method for multipicative [sic] noise\" (fork of GitHub repo by Villa Mart\u00edn) </p> </li> <li> <p>Buend\u00eda et al, 2020: \"Feedback mechanisms for self-organization to the edge of a phase transition\" </p> </li> <li> <p>Dornic et al, 2005: \"Integration of Langevin equations with multiplicative noise and the viability of field theories for absorbing phase transitions\" </p> </li> <li> <p>Pechenik &amp; Levine, 1999: \"Interfacial velocity corrections due to multiplicative noise\" </p> </li> <li> <p>Villa Mart\u00edn et al, 2014: \"Eluding catastrophic shifts\" </p> </li> <li> <p>Villa Mart\u00edn, 2019  (GitHub repo): \"Dornic integration method for multipicative [sic] noise\" [shared PDF] </p> </li> <li> <p>Weissmann et al, 2018: \"Simulation of spatial systems with demographic noise\" </p> </li> </ul>"},{"location":"serialize-reference/","title":"serialize.py","text":""},{"location":"serialize-reference/#lvn.serialize.is_serializable","title":"is_serializable","text":"<pre><code>is_serializable(value: Any) -&gt; bool\n</code></pre> <p>Check value is serializable and can be written to a JSON file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>true if value is serializable.</p> </li> </ul> Source code in <code>lvn/serialize.py</code> <pre><code>def is_serializable(value: Any,) -&gt; bool:\n    \"\"\"\n    Check value is serializable and can be written to a JSON file.\n\n    Args:\n        value: to be checked.\n\n    Returns: \n        true if value is serializable.\n    \"\"\"\n    try:\n        dumps(value)\n        return True\n    except TypeError:\n        return False\n</code></pre>"},{"location":"serialize-reference/#lvn.serialize.is_serializable(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>to be checked.</p>"},{"location":"serialize-reference/#lvn.serialize.from_serializable","title":"from_serializable","text":"<pre><code>from_serializable(value: Any, module: Any) -&gt; Any\n</code></pre> <p>Convert dict from serializable version.</p> <p>Parameters:</p> <p>Returns:  converted value.</p> Source code in <code>lvn/serialize.py</code> <pre><code>def from_serializable(value: Any, module: Any) -&gt; Any:\n    \"\"\"\n    Convert dict from serializable version.\n\n    Args:\n        value: to be converted.\n        module: dplvn or other class module\n\n    Returns:  converted value.\n    \"\"\"\n    match type(value):\n        case builtins.str:\n            match value:\n                case \"D1\":\n                    return module.D1\n                case \"D2\":\n                    return module.D2\n                case \"D3\":\n                    return module.D3\n                case \"RANDOM_UNIFORM\":\n                    return module.RANDOM_UNIFORM\n                case \"RANDOM_GAUSSIAN\":\n                    return module.RANDOM_GAUSSIAN\n                case \"CONSTANT_VALUE\":\n                    return module.CONSTANT_VALUE\n                case \"SINGLE_SEED\":\n                    return module.SINGLE_SEED\n                case \"RUNGE_KUTTA\":\n                    return module.RUNGE_KUTTA\n                case \"EULER\":\n                    return module.EULER\n                case _:\n                    return None\n        case builtins.tuple | builtins.list:\n            combo: list = []\n            if type(value[0])!=builtins.str:\n                return tuple(value)\n            for value_ in value:\n                match value_:\n                    case \"BOUNDED\":\n                        combo += [module.BOUNDED]\n                        continue\n                    case \"PERIODIC\":\n                        combo += [module.PERIODIC]\n                        continue\n                    case \"FLOATING\":\n                        combo += [module.FLOATING]\n                        continue\n                    case \"FIXED_VALUE\":\n                        combo += [module.FIXED_VALUE]\n                        continue\n                    case \"FIXED_FLUX\":\n                        combo += [module.FIXED_FLUX]\n                        continue\n                    case _:\n                        combo += [None]\n                        continue\n            return tuple(combo)\n        case _:\n            return value\n</code></pre>"},{"location":"serialize-reference/#lvn.serialize.from_serializable(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>to be converted.</p>"},{"location":"serialize-reference/#lvn.serialize.from_serializable(module)","title":"<code>module</code>","text":"(<code>Any</code>)           \u2013            <p>dplvn or other class module</p>"},{"location":"serialize-reference/#lvn.serialize.to_serializable","title":"to_serializable","text":"<pre><code>to_serializable(value: Any, module: Any) -&gt; Any\n</code></pre> <p>Convert value into serializable version.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>serializable value.</p> </li> </ul> Source code in <code>lvn/serialize.py</code> <pre><code>def to_serializable(value: Any, module: Any,) -&gt; Any:\n    \"\"\"\n    Convert value into serializable version.\n\n    Args:\n        value: to be converted.\n        module: dplvn or other class module\n\n    Returns: \n        serializable value.\n    \"\"\"\n    match type(value):\n        case builtins.str:\n            return value\n        case np.float64 | builtins.float:\n            return float(value)\n        case builtins.int:\n            return int(value)\n        case builtins.bool:\n            return value\n        case builtins.list:\n            return value\n        case module.GridDimension:\n            match value:\n                case module.D1:\n                    return \"D1\"\n                case module.D2:\n                    return \"D2\"\n                case module.D3:\n                    return \"D3\"\n                case _:\n                    return None\n        case module.InitialCondition:\n            match value:\n                case module.RANDOM_UNIFORM:\n                     return \"RANDOM_UNIFORM\"\n                case module.RANDOM_GAUSSIAN:\n                     return \"RANDOM_GAUSSIAN\"\n                case module.CONSTANT_VALUE:\n                     return \"CONSTANT_VALUE\"\n                case module.SINGLE_SEED:\n                     return \"SINGLE_SEED\"\n                case _:\n                    return None\n        case module.IntegrationMethod:\n            match value:\n                case module.RUNGE_KUTTA:\n                    return \"RUNGE_KUTTA\"\n                case module.EULER:\n                    return \"EULER\"\n                case _:\n                    return None\n        case builtins.tuple:\n            if is_serializable(value[0]) and is_serializable(value):\n                return value\n            combo: list = []\n            for value_ in value:\n                match value_:\n                    case module.BOUNDED:\n                        combo += [\"BOUNDED\"]\n                        continue\n                    case module.PERIODIC:\n                        combo += [\"PERIODIC\"]\n                        continue\n                    case module.FLOATING:\n                        combo += [\"FLOATING\"] \n                        continue\n                    case module.FIXED_VALUE:\n                        combo += [\"FIXED_VALUE\"] \n                        continue\n                    case module.FIXED_FLUX :\n                        combo += [\"FIXED_FLUX\"] \n                        continue\n                    case _:\n                        combo += [None]\n                        continue\n            return combo\n        case np.ndarray:\n            return value.tolist()\n        case _:\n            return value\n</code></pre>"},{"location":"serialize-reference/#lvn.serialize.to_serializable(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>to be converted.</p>"},{"location":"serialize-reference/#lvn.serialize.to_serializable(module)","title":"<code>module</code>","text":"(<code>Any</code>)           \u2013            <p>dplvn or other class module</p>"},{"location":"simulation-reference/","title":"simulation.py","text":""},{"location":"simulation-reference/#lvn.dp.simulation.Simulation","title":"Simulation","text":"<pre><code>Simulation(name: str | None, path: list[str], info: dict, do_verbose: bool = True)\n</code></pre> <p>Class to manage a single DP Langevin field integration.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>exec</code>             \u2013              <p>Carry out all simulation steps, including initialization &amp; running.</p> </li> <li> <code>initialize</code>             \u2013              <p>Create and initialize a <code>dpvln.SimSP</code> class instance.</p> </li> <li> <code>plot</code>             \u2013              <p>Generate all the required graphs and images.</p> </li> <li> <code>run</code>             \u2013              <p>Execute a <code>dpvln.SimSP</code> simulation.</p> </li> <li> <code>run_wrapper</code>             \u2013              <p>Wrapper around <code>dpvln.SimSP</code> run to provide timing.</p> </li> <li> <code>save</code>             \u2013              <p>Export outfo JSON, graphs, and data files.</p> </li> </ul> Source code in <code>lvn/dp/simulation.py</code> <pre><code>def __init__(\n        self, \n        name: str | None, \n        path: list[str], \n        info: dict, \n        do_verbose: bool=True,\n    ) -&gt; None:\n    \"\"\"\n    Constructor.\n\n    Args:\n        name: of sim constructed from parameters etc\n        path: path to file\n        info: dictionary containing sim coefficients, model parameters, etc\n        do_verbose: flag whether to use tqdm progress bar, report \n            from `dplvn.SimDP`\n    \"\"\"\n    self.analysis: dict = info[\"Analysis\"]\n    self.parameters: dict = info[\"Parameters\"]\n    self.misc: dict = info[\"Misc\"]\n\n    # Henkel et al, 2008\n    self.analysis.update({\n        \"dp_\u03b2\": 0.5834,\n        \"dp_\u03bd_pp\": 0.7333,\n        \"dp_\u03bd_ll\": 1.2950,\n        \"dp_\u03b4\": 0.4505,\n        \"dp_z\": 1.7660,\n    })\n    self.misc[\"path\"] = path + [set_name(\n        self.parameters, self.analysis, do_dir=True,\n    )]\n    if name is None:\n        self.misc[\"name\"] = set_name(\n            self.parameters, self.analysis, do_dir=False,\n        )\n    # elif name!=set_name(self.parameters, self.analysis,):\n    #     raise NameError(f\"Problem with {name}\")\n    else:\n        self.misc[\"name\"] = name\n        self.misc[\"path\"] = path\n    # else:\n    #     raise NameError(f\"Problem with {name}\")\n    self.misc[\"dplvn_version\"] = dplvn.__version__\n    self.misc[\"date_time\"] \\\n        = datetime.now().replace(microsecond=0).isoformat(sep=\" \")\n\n    self.do_verbose: bool = do_verbose\n    self.t_epochs: NDArray = np.empty([])\n    self.mean_densities: NDArray= np.empty([])\n    self.density_dict: dict[float, NDArray] = {}\n    self.density_image_dict: dict[int, Any] = {}\n</code></pre>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation(name)","title":"<code>name</code>","text":"(<code>str | None</code>)           \u2013            <p>of sim constructed from parameters etc</p>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation(path)","title":"<code>path</code>","text":"(<code>list[str]</code>)           \u2013            <p>path to file</p>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation(info)","title":"<code>info</code>","text":"(<code>dict</code>)           \u2013            <p>dictionary containing sim coefficients, model parameters, etc</p>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation(do_verbose)","title":"<code>do_verbose</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>flag whether to use tqdm progress bar, report  from <code>dplvn.SimDP</code></p>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.exec","title":"exec","text":"<pre><code>exec() -&gt; Sequence[tuple]\n</code></pre> <p>Carry out all simulation steps, including initialization &amp; running.</p> <p>Returns:</p> <ul> <li> <code>Sequence[tuple]</code>           \u2013            <p>serialized versions of sim epoch times, mean grid densities, and </p> </li> <li> <code>Sequence[tuple]</code>           \u2013            <p>computation run time.</p> </li> </ul> Source code in <code>lvn/dp/simulation.py</code> <pre><code>def exec(self) -&gt; Sequence[tuple]:\n    \"\"\"\n    Carry out all simulation steps, including initialization &amp; running.\n\n    Returns:\n        serialized versions of sim epoch times, mean grid densities, and \n        computation run time.\n    \"\"\"\n    self.initialize()\n    computation_time_report: str = self.run_wrapper()\n    if self.do_verbose:\n        print(computation_time_report)\n    return (\n        tuple(self.t_epochs.tolist()), \n        tuple(self.mean_densities.tolist()),\n        self.misc[\"computation_time\"],\n    )\n</code></pre>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; None\n</code></pre> <p>Create and initialize a <code>dpvln.SimSP</code> class instance.</p> Source code in <code>lvn/dp/simulation.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Create and initialize a `dpvln.SimSP` class instance.\n    \"\"\"\n    self.sim = dplvn.SimDP(**self.parameters, do_verbose=self.do_verbose,)\n    if not self.sim.initialize(self.misc[\"n_round_\u0394t_summation\"]):\n        raise Exception(\"Failed to initialize sim\")\n    self.analysis[\"n_epochs\"] = self.sim.get_n_epochs()\n</code></pre>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.plot","title":"plot","text":"<pre><code>plot() -&gt; None\n</code></pre> <p>Generate all the required graphs and images.</p> Source code in <code>lvn/dp/simulation.py</code> <pre><code>def plot(self) -&gt; None:\n    \"\"\"\n    Generate all the required graphs and images.\n    \"\"\"\n    self.graphs: VizDP = VizDP()\n    self.images: VizDP = VizDP()\n    self.graphs.plot_mean_density_evolution(\n        \"\u03c1_t_loglog\",\n        self.parameters, self.analysis, self.misc,\n        self.t_epochs, self.mean_densities, \n        do_rescale=False, y_sf=0.75,\n    )\n    self.graphs.plot_mean_density_evolution(\n        \"\u03c1_t_rescaled\",\n        self.parameters, self.analysis, self.misc,\n        self.t_epochs, self.mean_densities, \n        do_rescale=True,\n    )\n</code></pre>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Execute a <code>dpvln.SimSP</code> simulation.</p> Source code in <code>lvn/dp/simulation.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Execute a `dpvln.SimSP` simulation.\n    \"\"\"\n    n_segments: int = self.misc[\"n_segments\"]\n    n_epochs: int = self.analysis[\"n_epochs\"]\n    n_segment_epochs: int = (n_epochs-1) // n_segments\n    if (n_segment_epochs*n_segments+1)!=n_epochs:\n        raise Exception(\n            f\"Failed to segment sim with {n_epochs} epochs \"\n            + f\"into {n_segments} segment(s)\"\n        )\n    t_epoch_: int\n    i_segment_: int\n    progress_bar: Callable = (\n        progress if self.do_verbose else progress_disabled\n    )\n    for i_segment_ in progress_bar(range(0, n_segments+1, 1)):\n        if i_segment_&gt;0 and not self.sim.run(n_segment_epochs):\n            raise Exception(\"Failed to run sim\")\n        if not self.sim.postprocess():\n            raise Exception(\"Failed to process sim results\")\n        # i_epoch = sim.get_i_current_epoch()\n        t_epoch_ = self.sim.get_t_current_epoch()\n        self.density_dict[t_epoch_] = self.sim.get_density()\n    self.t_epochs = self.sim.get_t_epochs()\n    self.mean_densities = self.sim.get_mean_densities()\n</code></pre>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.run_wrapper","title":"run_wrapper","text":"<pre><code>run_wrapper() -&gt; str\n</code></pre> <p>Wrapper around <code>dpvln.SimSP</code> run to provide timing.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>printable string describing computation (sim run) time</p> </li> </ul> Source code in <code>lvn/dp/simulation.py</code> <pre><code>def run_wrapper(self) -&gt; str:\n    \"\"\"\n    Wrapper around `dpvln.SimSP` run to provide timing.\n\n    Returns:\n        printable string describing computation (sim run) time\n    \"\"\"\n    tick: float = perf_counter()\n    self.run()\n    tock: float = perf_counter()\n    self.misc[\"computation_time\"] = f\"{timedelta(seconds=round(tock-tick))}\"\n    return (f\"Computation time = {self.misc[\"computation_time\"]}\")\n</code></pre>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.save","title":"save","text":"<pre><code>save(module: Any, do_dummy: bool = False, do_verbose: bool = False) -&gt; None\n</code></pre> <p>Export outfo JSON, graphs, and data files.</p> <p>Parameters:</p> Source code in <code>lvn/dp/simulation.py</code> <pre><code>def save(\n        self, \n        module: Any,\n        do_dummy: bool=False, \n        do_verbose: bool=False,\n    ) -&gt; None:\n    \"\"\"\n    Export outfo JSON, graphs, and data files.\n\n    Args:\n        module: dplvn or other class module\n        do_dummy: just print (possibly create) the output folders\n        do_verbose: report how the exporting is going\n    \"\"\"\n    if self.do_verbose | do_verbose:\n        print(f\"Outfo/graph/data path:  {self.misc[\"path\"]}\")\n    seed_dir_name: str = f\"rs{self.parameters[\"random_seed\"]}\"\n\n    outfo_path: str = \\\n        create_directories(\n            (os.path.pardir, *self.misc[\"path\"]), seed_dir_name,\n        )\n    outfo: dict = {\n        \"Parameters\" : self.parameters,\n        \"Analysis\" : self.analysis,\n        \"Misc\" : self.misc\n    }        \n    if not do_dummy:\n        _ = export_info(outfo_path, \"Outfo\", outfo, module,)\n\n    if self.misc[\"do_export_graphs\"]:\n        graphs_path: str = \\\n            create_directories(\n                (os.path.pardir,  *self.misc[\"path\"], seed_dir_name,), \".\",\n            )\n        if not do_dummy:\n            _ = export_plots(\n                    self.graphs.fdict, \n                    graphs_path,\n                    do_verbose=self.do_verbose,\n                )\n\n    if self.misc[\"do_export_data\"]:\n        data_path: str = \\\n            create_directories(\n                (os.path.pardir, *self.misc[\"path\"], seed_dir_name,), \".\", \n            )\n        if not do_dummy:\n            np.savez_compressed(\n                os.path.join(data_path, \"\u03c1_t\",), \n                t_epochs=self.t_epochs,\n                mean_densities=self.mean_densities,\n            )\n            data_npz: NpzFile = np.load(\n                os.path.join(data_path, \"\u03c1_t\"+\".npz\",), \n            )\n            data_npz[\"t_epochs\"][-10:], data_npz[\"mean_densities\"][-10:]\n</code></pre>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.save(module)","title":"<code>module</code>","text":"(<code>Any</code>)           \u2013            <p>dplvn or other class module</p>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.save(do_dummy)","title":"<code>do_dummy</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>just print (possibly create) the output folders</p>"},{"location":"simulation-reference/#lvn.dp.simulation.Simulation.save(do_verbose)","title":"<code>do_verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>report how the exporting is going</p>"},{"location":"tests-reference/","title":"Tests","text":""},{"location":"tests-reference/#demo_periodicpy","title":"demo_periodic.py","text":"<p>Example 2D grid with periodic edge (toroidal) topology. Run with:</p> <pre><code>    python tests/demo_periodic.py\n</code></pre>"},{"location":"tests-reference/#demo_mixedpy","title":"demo_mixed.py","text":"<p>Example 2D grid with mixed edge (cylindrical) topology. Run with:</p> <pre><code>    python tests/demo_mixed.py\n</code></pre>"},{"location":"tests-reference/#demoipynb","title":"Demo.ipynb","text":"<p>2d grid demo. Run either in Jupyter or JupyterLab, or using IPython:</p> <pre><code>ipython tests/Demo.ipynb\n</code></pre> <p>but be aware that two image PNG files will be written to the current directory.</p>"},{"location":"utils-reference/","title":"utils.py","text":""},{"location":"utils-reference/#lvn.utils.make_dataframe","title":"make_dataframe","text":"<pre><code>make_dataframe(p: dict) -&gt; DataFrame\n</code></pre> <p>Convert a dictionary into a pandas dataframe to prettify it.</p> <p>The keys becomes the \"index\" column. The dictionary values become a column labeled \"value\".</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>dataframe conversion</p> </li> </ul> Source code in <code>lvn/utils.py</code> <pre><code>def make_dataframe(p: dict) -&gt; DataFrame:\n    \"\"\"\n    Convert a dictionary into a pandas dataframe to prettify it.\n\n    The keys becomes the \"index\" column.\n    The dictionary values become a column labeled \"value\".\n\n    Args:\n        p: input dictionary\n\n    Returns:\n        dataframe conversion\n    \"\"\"\n    df: DataFrame \\\n        = DataFrame.from_dict(p, orient=\"index\").rename_axis(\"name\")\n    df.rename(columns={0:\"value\"}, inplace=True,)\n    return df\n</code></pre>"},{"location":"utils-reference/#lvn.utils.make_dataframe(p)","title":"<code>p</code>","text":"(<code>dict</code>)           \u2013            <p>input dictionary</p>"},{"location":"utils-reference/#lvn.utils.make_multisim_title","title":"make_multisim_title","text":"<pre><code>make_multisim_title(\n    p: dict, analysis: dict, a_range: tuple[float, float] | None\n) -&gt; str\n</code></pre> <p>Define a title string to use when annotating plots.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>title string</p> </li> </ul> Source code in <code>lvn/utils.py</code> <pre><code>def make_multisim_title(\n    p: dict,\n    analysis: dict,\n    a_range: tuple[float, float] | None,\n) -&gt; str:\n    \"\"\"\n    Define a title string to use when annotating plots.\n\n    Args:\n        p: parameters dictionary\n        analysis: analysis dictionary\n        a_range: span of values of linear coefficient \"a\"\n\n    Returns:\n        title string\n    \"\"\"\n    # a_range may be in reverse order\n        # + r\"$n_\\mathsf{sims}$\"+f\"={p.n_sims}   \" \\\n    title: str = \"\"\\\n        + (\n            rf\"$a \\in $[{min(a_range):0.4f}, {max(a_range):0.4f}]   \" \n            if a_range is not None else \"\"\n        ) \\\n        + rf\"$b$={p[\"linear\"]}   \"  \\\n        + rf\"$D$={p[\"diffusion\"]}   \" \\\n        + rf\"$\u03c2$={p[\"noise\"]}   \" \\\n        + \"\\n\" \\\n        + rf\"$a_c$={(analysis[\"a_c\"]):0.4f}    \" \\\n        + rf\"$n_x$={p[\"n_x\"]}   \" \\\n        + rf\"$n_y$={p[\"n_y\"]}   \"   \\\n        + rf\"$\\Delta$$x$={p[\"\u0394x\"]}   \" \\\n        + rf\"$\\Delta$$t$={p[\"\u0394t\"]}   \" \\\n        + rf\"$t$={p[\"t_total\"]:g}\"\n    return title\n</code></pre>"},{"location":"utils-reference/#lvn.utils.make_multisim_title(p)","title":"<code>p</code>","text":"(<code>dict</code>)           \u2013            <p>parameters dictionary</p>"},{"location":"utils-reference/#lvn.utils.make_multisim_title(analysis)","title":"<code>analysis</code>","text":"(<code>dict</code>)           \u2013            <p>analysis dictionary</p>"},{"location":"utils-reference/#lvn.utils.make_multisim_title(a_range)","title":"<code>a_range</code>","text":"(<code>tuple[float, float] | None</code>)           \u2013            <p>span of values of linear coefficient \"a\"</p>"},{"location":"utils-reference/#lvn.utils.make_name_title","title":"make_name_title","text":"<pre><code>make_name_title(\n    field_name: str,\n    p: dict,\n    analysis: dict,\n    t_total: float | None = None,\n    a_range: tuple[float, float] | None = None,\n    do_multisim: bool = False,\n) -&gt; tuple[str, str]\n</code></pre> <p>Define (file) name and (plot) title strings.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>name and title strings as tuple</p> </li> </ul> Source code in <code>lvn/utils.py</code> <pre><code>def make_name_title(\n    field_name: str, \n    p: dict,\n    analysis: dict,\n    t_total: float | None = None,\n    a_range: tuple[float, float] | None = None,\n    do_multisim: bool = False,\n) -&gt; tuple[str,str]:\n    \"\"\"\n    Define (file) name and (plot) title strings.\n\n    Args:\n        p: parameters dictionary\n        analysis: analysis dictionary\n        t_total: time span of simulation\n        a_range: span of values of linear coefficient \"a\"\n        do_multisim: flag if doing multiple simulations\n\n    Returns:\n        name and title strings as tuple\n    \"\"\"\n    set_name_: Callable = partial(\n        set_name,\n        p,\n        analysis,\n        field_name,\n    )\n    name:str  = (\n        set_name_(t_total=t_total, do_multisim=True,) \n        if do_multisim \n        else set_name_()\n    )\n    title: str = (\n        make_multisim_title(p, analysis, a_range,) if do_multisim\n        else make_sim_title(p, analysis, )\n    )\n    return (name, title,)\n</code></pre>"},{"location":"utils-reference/#lvn.utils.make_name_title(p)","title":"<code>p</code>","text":"(<code>dict</code>)           \u2013            <p>parameters dictionary</p>"},{"location":"utils-reference/#lvn.utils.make_name_title(analysis)","title":"<code>analysis</code>","text":"(<code>dict</code>)           \u2013            <p>analysis dictionary</p>"},{"location":"utils-reference/#lvn.utils.make_name_title(t_total)","title":"<code>t_total</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>time span of simulation</p>"},{"location":"utils-reference/#lvn.utils.make_name_title(a_range)","title":"<code>a_range</code>","text":"(<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>span of values of linear coefficient \"a\"</p>"},{"location":"utils-reference/#lvn.utils.make_name_title(do_multisim)","title":"<code>do_multisim</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>flag if doing multiple simulations</p>"},{"location":"utils-reference/#lvn.utils.make_sim_title","title":"make_sim_title","text":"<pre><code>make_sim_title(p: dict, analysis: dict, module: Any, do_omit_a: bool = False) -&gt; str\n</code></pre> <p>Define a title string to use when annotating plots.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>title string</p> </li> </ul> Source code in <code>lvn/utils.py</code> <pre><code>def make_sim_title(\n    p: dict,\n    analysis: dict,\n    module: Any,\n    do_omit_a: bool=False,\n) -&gt; str:\n    \"\"\"\n    Define a title string to use when annotating plots.\n\n    Args:\n        p: parameters dictionary\n        analysis: analysis dictionary\n        module: dplvn or other class module\n        do_omit_a: skip linear coefficient \"a\" in string\n\n    Returns:\n        title string\n\n    \"\"\"\n    def grid_topology(i: int) -&gt; str:\n        return \"bnd\" if p[\"grid_topologies\"][i]==module.BOUNDED else \"pdc\"\n\n    def boundary_condition(i: int) -&gt; str:\n        match p[\"boundary_conditions\"][i]:\n            case module.FIXED_VALUE:\n                return \"fxd\"\n            case module.FIXED_FLUX:\n                return \"flx\"\n            case module.FLOATING:\n                return \"flt\"\n            case _:\n                return \"\";\n\n    title: str = \"\"\\\n        + (\n            rf\"$a$={p[\"linear\"]:0.5f}   \" if not do_omit_a \n            else rf\"$a_c \\approx ${analysis[\"a_c\"]:0.5f}              \"\n        ) \\\n        + rf\"$b$={p[\"quadratic\"]}   \" \\\n        + rf\"$D$={p[\"diffusion\"]}   \" \\\n        + rf\"$\u03b7$={p[\"noise\"]}\" \\\n        + (\n            rf\"      $rs$={p[\"random_seed\"]}      \" if not do_omit_a \n            else \"          \"\n        ) \\\n        + (\n            rf\"$a_c \\approx ${analysis[\"a_c\"]:0.5f}\" if not do_omit_a \n            else \"\"\n        ) \\\n        + \"\\n\" \\\n        + rf\"$n_x$={p[\"grid_size\"][0]}  \" \\\n        + rf\"$n_y$={p[\"grid_size\"][1]}   \"   \\\n        + rf\"$\\Delta$$x$={p[\"dx\"]}   \" \\\n        + rf\"$\\Delta$$t$={p[\"dt\"]}   \" \\\n        + rf\"gt:({grid_topology(0)}, {grid_topology(1)})  \" \\\n        + rf\"bc:({boundary_condition(0)}, {boundary_condition(1)}, \" \\\n            +rf\"{boundary_condition(2)}, {boundary_condition(3)})   \" \n        # + (rf\"$t$={t_epoch:08.2f}     \" if t_epoch is not None else \"\")\n    return title\n</code></pre>"},{"location":"utils-reference/#lvn.utils.make_sim_title(p)","title":"<code>p</code>","text":"(<code>dict</code>)           \u2013            <p>parameters dictionary</p>"},{"location":"utils-reference/#lvn.utils.make_sim_title(analysis)","title":"<code>analysis</code>","text":"(<code>dict</code>)           \u2013            <p>analysis dictionary</p>"},{"location":"utils-reference/#lvn.utils.make_sim_title(module)","title":"<code>module</code>","text":"(<code>Any</code>)           \u2013            <p>dplvn or other class module</p>"},{"location":"utils-reference/#lvn.utils.make_sim_title(do_omit_a)","title":"<code>do_omit_a</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>skip linear coefficient \"a\" in string</p>"},{"location":"utils-reference/#lvn.utils.set_name","title":"set_name","text":"<pre><code>set_name(\n    p: dict,\n    a: dict,\n    field_name: str | None = None,\n    suffix: str = \"\",\n    t_epoch: float | None = None,\n    do_parent: bool = False,\n    do_dir: bool = False,\n) -&gt; str\n</code></pre> <p>Define a simulation name string that includes model parameters for info.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>name string</p> </li> </ul> Source code in <code>lvn/utils.py</code> <pre><code>def set_name(\n    p: dict,\n    a: dict,\n    field_name: str | None=None,\n    suffix: str=\"\",\n    t_epoch: float | None=None,\n    do_parent: bool=False,\n    do_dir: bool=False,\n) -&gt; str:\n    \"\"\"\n    Define a simulation name string that includes model parameters for info.\n\n    Args:\n        p: parameters dictionary\n        a: analysis dictionary\n        field_name: name (e.g. '\u03c1') of Langevin field variable\n        suffix: optional\n        t_epoch: time slice of sim\n        do_parent: generate a 'parent' folder name\n        do_dir: generate a detailed folder name\n\n    Returns:\n        name string\n    \"\"\"\n    to = lambda x: ((f\"{x}\").replace(\".\",\"p\",)).replace(\"-\",\"neg\",)\n    to5 = lambda x: ((f\"{x:0.5f}\").replace(\".\",\"p\",)).replace(\"-\",\"neg\",)\n    name: str\n    if do_dir:\n        name = f\"a{to5(p[\"linear\"])}\"\n    else:\n        name = \\\n            (field_name+\"_\" if field_name is not None else \"\") \\\n            + (f\"\" if do_parent else f\"a{to5(p[\"linear\"])}_\") \\\n            + f\"b{to(p[\"quadratic\"])}\" \\\n            + f\"_D{to(p[\"diffusion\"])}\" \\\n            + f\"_\u03b7{to(p[\"noise\"])}\" \\\n            + f\"_x{p[\"grid_size\"][0]}\" \\\n            + f\"_y{p[\"grid_size\"][1]}\" \\\n            + f\"_\u0394x{to(p[\"dx\"])}\" \\\n            + f\"_\u0394t{to(p[\"dt\"])}\" \\\n            + (to(f\"_t{t_epoch:08.2f}\") if t_epoch is not None else \"\") \\\n            + suffix\n            # + f\"_rs{to(p[\"random_seed\"])}\" \n    return name\n</code></pre>"},{"location":"utils-reference/#lvn.utils.set_name(p)","title":"<code>p</code>","text":"(<code>dict</code>)           \u2013            <p>parameters dictionary</p>"},{"location":"utils-reference/#lvn.utils.set_name(a)","title":"<code>a</code>","text":"(<code>dict</code>)           \u2013            <p>analysis dictionary</p>"},{"location":"utils-reference/#lvn.utils.set_name(field_name)","title":"<code>field_name</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>name (e.g. '\u03c1') of Langevin field variable</p>"},{"location":"utils-reference/#lvn.utils.set_name(suffix)","title":"<code>suffix</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>optional</p>"},{"location":"utils-reference/#lvn.utils.set_name(t_epoch)","title":"<code>t_epoch</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>time slice of sim</p>"},{"location":"utils-reference/#lvn.utils.set_name(do_parent)","title":"<code>do_parent</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>generate a 'parent' folder name</p>"},{"location":"utils-reference/#lvn.utils.set_name(do_dir)","title":"<code>do_dir</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>generate a detailed folder name</p>"},{"location":"viz-reference/","title":"viz.py","text":""},{"location":"viz-reference/#lvn.viz.Viz","title":"Viz","text":"<pre><code>Viz(dpi: int = 100, font_size: int = 11)\n</code></pre> <p>Provide a visualization base class.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>dpi</code>               (<code>int</code>)           \u2013            <p>resolution for rasterized images</p> </li> <li> <code>font_size</code>               (<code>int</code>)           \u2013            <p>general font size</p> </li> <li> <code>fdict</code>               (<code>dict[Any, Any]</code>)           \u2013            <p>dictionary to which each figure is appended as it is generated</p> </li> <li> <code>colors</code>               (<code>Callable</code>)           \u2013            <p>list of colors</p> </li> <li> <code>n_colors</code>               (<code>int</code>)           \u2013            <p>number of colors</p> </li> <li> <code>color_cycle</code>               (<code>Callable</code>)           \u2013            <p>color property cycle</p> </li> <li> <code>markers</code>               (<code>tuple</code>)           \u2013            <p>list of markers</p> </li> <li> <code>n_markers</code>               (<code>int</code>)           \u2013            <p>number of markers</p> </li> <li> <code>marker_cycle</code>               (<code>cycle</code>)           \u2013            <p>cycle of markers</p> </li> <li> <code>linestyle_list</code>               (<code>tuple</code>)           \u2013            <p>list of line styles (solid, dashdot, dashed, custom dashed)</p> </li> <li> <code>color</code>               (<code>Callable</code>)           \u2013            <p>return i^th color</p> </li> <li> <code>marker</code>               (<code>Callable</code>)           \u2013            <p>return i^th marker</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>create_figure</code>             \u2013              <p>Initialize a <code>MatPlotLib</code> figure.</p> </li> <li> <code>get_aspect</code>             \u2013              <p>Get aspect ratio of graph.</p> </li> <li> <code>get_fonts</code>             \u2013              <p>Fetch the names of all the font families available on the system.</p> </li> <li> <code>naturalize</code>             \u2013              <p>Adjust graph aspect ratio into 'natural' ratio.</p> </li> <li> <code>stretch</code>             \u2013              <p>Stretch graph axes by respective factors.</p> </li> </ul> Source code in <code>lvn/viz.py</code> <pre><code>def __init__(self, dpi: int = 100, font_size: int = 11) -&gt; None:\n    \"\"\"Initialize.\"\"\"\n    self.dpi = dpi\n    self.font_size = font_size\n    self.fdict = {}\n    prop_cycle = plt.rcParams[\"axes.prop_cycle\"]\n    self.colors = prop_cycle.by_key()[\"color\"]  # type: ignore\n    self.n_colors = len(self.colors)  # type: ignore\n    self.color_cycle = cycle(self.colors)  # type: ignore\n    self.markers = (\"o\", \"s\", \"v\", \"p\", \"*\", \"D\", \"X\", \"^\", \"h\", \"P\")\n    self.n_markers = len(self.markers)\n    self.marker_cycle = cycle(self.markers)\n    self.linestyle_list = (\"solid\", \"dashdot\", \"dashed\", (0, (3, 1, 1, 1)))\n\n    color_ = lambda i_: self.colors[i_ % self.n_colors]  # type: ignore\n    marker_ = lambda i_: self.markers[i_ % self.n_markers]  # type: ignore\n    self.color = color_  # type: ignore\n    self.marker = marker_  # type: ignore\n    self.font_family = \"Arial\" #if \"Arial\" in self.get_fonts() else \"Helvetica\"\n    try:\n        mpl.rc(\"font\", size=self.font_size, family=self.font_family)\n    except:\n        mpl.rc(\"font\", size=self.font_size, family=\"\")\n</code></pre>"},{"location":"viz-reference/#lvn.viz.Viz(dpi)","title":"<code>dpi</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>resolution for rasterized images</p>"},{"location":"viz-reference/#lvn.viz.Viz(font_size)","title":"<code>font_size</code>","text":"(<code>int</code>, default:                   <code>11</code> )           \u2013            <p>general font size</p>"},{"location":"viz-reference/#lvn.viz.Viz.create_figure","title":"create_figure","text":"<pre><code>create_figure(\n    fig_name: str, fig_size: tuple[float, float] | None = None, dpi: int | None = None\n) -&gt; Figure\n</code></pre> <p>Initialize a <code>MatPlotLib</code> figure.</p> <p>Set its size and dpi, set the font size, choose the Arial font family if possible, and append it to the figures dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>reference to figure</p> </li> </ul> Source code in <code>lvn/viz.py</code> <pre><code>def create_figure(\n    self,\n    fig_name: str,\n    fig_size: tuple[float, float] | None = None,\n    dpi: int | None = None,\n) -&gt; Figure:\n    \"\"\"\n    Initialize a `MatPlotLib` figure.\n\n    Set its size and dpi, set the font size,\n    choose the Arial font family if possible,\n    and append it to the figures dictionary.\n\n    Args:\n        fig_name:\n            name of figure; used as key in figures dictionary\n        fig_size:\n            optional width and height of figure in inches\n        dpi:\n            rasterization resolution\n\n    Returns:\n        reference to figure\n    \"\"\"\n    fig_size_: tuple[float, float] = (\n        (8, 8) if fig_size is None else fig_size\n    )\n    dpi_: float = self.dpi if dpi is None else dpi\n    logging.info(\n        \"gmplib.plot.GraphingBase:\\n   \"\n        + f\"Creating plot: {fig_name} size={fig_size_} @ {dpi_} dpi\"\n    )\n    fig = plt.figure()\n    self.fdict.update({fig_name: fig})\n    if fig_size_ is not None:\n        fig.set_size_inches(*fig_size_)\n    fig.set_dpi(dpi_)\n    return fig\n</code></pre>"},{"location":"viz-reference/#lvn.viz.Viz.create_figure(fig_name)","title":"<code>fig_name</code>","text":"(<code>str</code>)           \u2013            <p>name of figure; used as key in figures dictionary</p>"},{"location":"viz-reference/#lvn.viz.Viz.create_figure(fig_size)","title":"<code>fig_size</code>","text":"(<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>optional width and height of figure in inches</p>"},{"location":"viz-reference/#lvn.viz.Viz.create_figure(dpi)","title":"<code>dpi</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>rasterization resolution</p>"},{"location":"viz-reference/#lvn.viz.Viz.get_aspect","title":"get_aspect","text":"<pre><code>get_aspect(axes: Axes) -&gt; float\n</code></pre> <p>Get aspect ratio of graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>aspect ratio</p> </li> </ul> Source code in <code>lvn/viz.py</code> <pre><code>def get_aspect(self, axes: Axes) -&gt; float: #type: ignore\n    \"\"\"\n    Get aspect ratio of graph.\n\n    Args:\n        axes:\n            the `axes` object of the figure\n\n    Returns:\n        aspect ratio\n    \"\"\"\n    # Total figure size\n    figWH: tuple[float, float] \\\n        = tuple(axes.get_figure().get_size_inches())  #type: ignore\n    figW, figH = figWH\n    # Axis size on figure\n    bounds: tuple[float, float, float, float] = axes.get_position().bounds\n    _, _, w, h = bounds\n    # Ratio of display units\n    disp_ratio: float = (figH * h) / (figW * w)\n    # Ratio of data units\n    # Negative over negative because of the order of subtraction\n    # logging.info(axes.get_ylim(),axes.get_xlim())\n    data_ratio: float = op.sub(*axes.get_ylim()) / op.sub(*axes.get_xlim())\n    aspect_ratio: float = disp_ratio / data_ratio\n    return aspect_ratio\n</code></pre>"},{"location":"viz-reference/#lvn.viz.Viz.get_aspect(axes)","title":"<code>axes</code>","text":"(<code>Axes</code>)           \u2013            <p>the <code>axes</code> object of the figure</p>"},{"location":"viz-reference/#lvn.viz.Viz.get_fonts","title":"get_fonts","text":"<pre><code>get_fonts() -&gt; List[str]\n</code></pre> <p>Fetch the names of all the font families available on the system.</p> Source code in <code>lvn/viz.py</code> <pre><code>def get_fonts(self) -&gt; List[str]:\n    \"\"\"Fetch the names of all the font families available on the system.\"\"\"\n    fpaths = matplotlib.font_manager.findSystemFonts()\n    fonts: list[str] = []\n    for fpath in fpaths:\n        try:\n            font = matplotlib.font_manager.get_font(fpath).family_name\n            fonts.append(font)\n        except RuntimeError as re:\n            logging.debug(f\"{re}: failed to get font name for {fpath}\")\n            pass\n    return fonts\n</code></pre>"},{"location":"viz-reference/#lvn.viz.Viz.naturalize","title":"naturalize","text":"<pre><code>naturalize(fig: Figure) -&gt; None\n</code></pre> <p>Adjust graph aspect ratio into 'natural' ratio.</p> Source code in <code>lvn/viz.py</code> <pre><code>def naturalize(self, fig: Figure) -&gt; None:\n    \"\"\"Adjust graph aspect ratio into 'natural' ratio.\"\"\"\n    axes: Axes = fig.gca() #type: ignore\n    # x_lim, y_lim = axes.get_xlim(), axes.get_ylim()\n    # axes.set_aspect((y_lim[1]-y_lim[0])/(x_lim[1]-x_lim[0]))\n    axes.set_aspect(1 / self.get_aspect(axes))\n</code></pre>"},{"location":"viz-reference/#lvn.viz.Viz.stretch","title":"stretch","text":"<pre><code>stretch(\n    fig: Figure,\n    xs: tuple[float, float] | None = None,\n    ys: tuple[float, float] | None = None,\n) -&gt; None\n</code></pre> <p>Stretch graph axes by respective factors.</p> Source code in <code>lvn/viz.py</code> <pre><code>def stretch(\n    self,\n    fig: Figure,\n    xs: tuple[float, float] | None = None,\n    ys: tuple[float, float] | None = None,\n) -&gt; None:\n    \"\"\"Stretch graph axes by respective factors.\"\"\"\n    axes: Axes = fig.gca() #type: ignore\n    if xs is not None:\n        x_lim = axes.get_xlim()\n        x_range = x_lim[1] - x_lim[0]\n        axes.set_xlim(\n            x_lim[0] - x_range * xs[0], x_lim[1] + x_range * xs[1]\n        )\n    if ys is not None:\n        y_lim = axes.get_ylim()\n        y_range = y_lim[1] - y_lim[0]\n        axes.set_ylim(\n            y_lim[0] - y_range * ys[0], y_lim[1] + y_range * ys[1]\n        )\n</code></pre>"},{"location":"vizdp-reference/","title":"vizdp.py","text":""},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP","title":"VizDP","text":"<pre><code>VizDP(dpi: int = 100, font_size: int = 11)\n</code></pre> <p>Visualization class for directed percolation simulations.</p> <p>Methods:</p> <ul> <li> <code>create_figure</code>             \u2013              <p>Initialize a <code>MatPlotLib</code> figure.</p> </li> <li> <code>get_aspect</code>             \u2013              <p>Get aspect ratio of graph.</p> </li> <li> <code>get_fonts</code>             \u2013              <p>Fetch the names of all the font families available on the system.</p> </li> <li> <code>multiplot_mean_density_evolution</code>             \u2013              <p>Plot an ensemble graph of the mean density \u03c1(t) versus time t for all sims.</p> </li> <li> <code>naturalize</code>             \u2013              <p>Adjust graph aspect ratio into 'natural' ratio.</p> </li> <li> <code>plot_density_image</code>             \u2013              <p>Generate an image grid of the Langevin density field.</p> </li> <li> <code>plot_mean_density_evolution</code>             \u2013              <p>Plot a graph of the mean density \u03c1(t) versus time t.</p> </li> <li> <code>stretch</code>             \u2013              <p>Stretch graph axes by respective factors.</p> </li> </ul> Source code in <code>lvn/viz.py</code> <pre><code>def __init__(self, dpi: int = 100, font_size: int = 11) -&gt; None:\n    \"\"\"Initialize.\"\"\"\n    self.dpi = dpi\n    self.font_size = font_size\n    self.fdict = {}\n    prop_cycle = plt.rcParams[\"axes.prop_cycle\"]\n    self.colors = prop_cycle.by_key()[\"color\"]  # type: ignore\n    self.n_colors = len(self.colors)  # type: ignore\n    self.color_cycle = cycle(self.colors)  # type: ignore\n    self.markers = (\"o\", \"s\", \"v\", \"p\", \"*\", \"D\", \"X\", \"^\", \"h\", \"P\")\n    self.n_markers = len(self.markers)\n    self.marker_cycle = cycle(self.markers)\n    self.linestyle_list = (\"solid\", \"dashdot\", \"dashed\", (0, (3, 1, 1, 1)))\n\n    color_ = lambda i_: self.colors[i_ % self.n_colors]  # type: ignore\n    marker_ = lambda i_: self.markers[i_ % self.n_markers]  # type: ignore\n    self.color = color_  # type: ignore\n    self.marker = marker_  # type: ignore\n    self.font_family = \"Arial\" #if \"Arial\" in self.get_fonts() else \"Helvetica\"\n    try:\n        mpl.rc(\"font\", size=self.font_size, family=self.font_family)\n    except:\n        mpl.rc(\"font\", size=self.font_size, family=\"\")\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.create_figure","title":"create_figure","text":"<pre><code>create_figure(\n    fig_name: str, fig_size: tuple[float, float] | None = None, dpi: int | None = None\n) -&gt; Figure\n</code></pre> <p>Initialize a <code>MatPlotLib</code> figure.</p> <p>Set its size and dpi, set the font size, choose the Arial font family if possible, and append it to the figures dictionary.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>reference to figure</p> </li> </ul> Source code in <code>lvn/viz.py</code> <pre><code>def create_figure(\n    self,\n    fig_name: str,\n    fig_size: tuple[float, float] | None = None,\n    dpi: int | None = None,\n) -&gt; Figure:\n    \"\"\"\n    Initialize a `MatPlotLib` figure.\n\n    Set its size and dpi, set the font size,\n    choose the Arial font family if possible,\n    and append it to the figures dictionary.\n\n    Args:\n        fig_name:\n            name of figure; used as key in figures dictionary\n        fig_size:\n            optional width and height of figure in inches\n        dpi:\n            rasterization resolution\n\n    Returns:\n        reference to figure\n    \"\"\"\n    fig_size_: tuple[float, float] = (\n        (8, 8) if fig_size is None else fig_size\n    )\n    dpi_: float = self.dpi if dpi is None else dpi\n    logging.info(\n        \"gmplib.plot.GraphingBase:\\n   \"\n        + f\"Creating plot: {fig_name} size={fig_size_} @ {dpi_} dpi\"\n    )\n    fig = plt.figure()\n    self.fdict.update({fig_name: fig})\n    if fig_size_ is not None:\n        fig.set_size_inches(*fig_size_)\n    fig.set_dpi(dpi_)\n    return fig\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.create_figure(fig_name)","title":"<code>fig_name</code>","text":"(<code>str</code>)           \u2013            <p>name of figure; used as key in figures dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.create_figure(fig_size)","title":"<code>fig_size</code>","text":"(<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>optional width and height of figure in inches</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.create_figure(dpi)","title":"<code>dpi</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>rasterization resolution</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.get_aspect","title":"get_aspect","text":"<pre><code>get_aspect(axes: Axes) -&gt; float\n</code></pre> <p>Get aspect ratio of graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>aspect ratio</p> </li> </ul> Source code in <code>lvn/viz.py</code> <pre><code>def get_aspect(self, axes: Axes) -&gt; float: #type: ignore\n    \"\"\"\n    Get aspect ratio of graph.\n\n    Args:\n        axes:\n            the `axes` object of the figure\n\n    Returns:\n        aspect ratio\n    \"\"\"\n    # Total figure size\n    figWH: tuple[float, float] \\\n        = tuple(axes.get_figure().get_size_inches())  #type: ignore\n    figW, figH = figWH\n    # Axis size on figure\n    bounds: tuple[float, float, float, float] = axes.get_position().bounds\n    _, _, w, h = bounds\n    # Ratio of display units\n    disp_ratio: float = (figH * h) / (figW * w)\n    # Ratio of data units\n    # Negative over negative because of the order of subtraction\n    # logging.info(axes.get_ylim(),axes.get_xlim())\n    data_ratio: float = op.sub(*axes.get_ylim()) / op.sub(*axes.get_xlim())\n    aspect_ratio: float = disp_ratio / data_ratio\n    return aspect_ratio\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.get_aspect(axes)","title":"<code>axes</code>","text":"(<code>Axes</code>)           \u2013            <p>the <code>axes</code> object of the figure</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.get_fonts","title":"get_fonts","text":"<pre><code>get_fonts() -&gt; List[str]\n</code></pre> <p>Fetch the names of all the font families available on the system.</p> Source code in <code>lvn/viz.py</code> <pre><code>def get_fonts(self) -&gt; List[str]:\n    \"\"\"Fetch the names of all the font families available on the system.\"\"\"\n    fpaths = matplotlib.font_manager.findSystemFonts()\n    fonts: list[str] = []\n    for fpath in fpaths:\n        try:\n            font = matplotlib.font_manager.get_font(fpath).family_name\n            fonts.append(font)\n        except RuntimeError as re:\n            logging.debug(f\"{re}: failed to get font name for {fpath}\")\n            pass\n    return fonts\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution","title":"multiplot_mean_density_evolution","text":"<pre><code>multiplot_mean_density_evolution(\n    name: str,\n    sims_info: dict,\n    sims_list: list[Any],\n    do_loglog: bool = True,\n    do_rescale: bool = False,\n    y_sf: float = 1,\n    n_digits: int = 6,\n    do_label_\u0394: bool = True,\n) -&gt; Figure\n</code></pre> <p>Plot an ensemble graph of the mean density \u03c1(t) versus time t for all sims.</p> <p>Depending on the arguments, the graph may plot DP-rescaled values,  and may have log-log axes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>Matplotlib figure instance.</p> </li> </ul> Source code in <code>lvn/dp/vizdp.py</code> <pre><code>def multiplot_mean_density_evolution(\n        self,\n        name: str, \n        sims_info: dict,\n        sims_list: list[Any],\n        do_loglog: bool=True,\n        do_rescale: bool=False,\n        y_sf: float=1,\n        n_digits: int=6,\n        do_label_\u0394: bool=True,\n    ) -&gt; Figure:\n    \"\"\"\n    Plot an ensemble graph of the mean density \u03c1(t) versus time t for all sims.\n\n    Depending on the arguments, the graph may plot DP-rescaled values, \n    and may have log-log axes.\n\n    Args:\n        name: of figure to be used as key in viz dictionary\n        sims_info: dictionary of ensemble\n        sims_list: list of all sim instances in the ensemble\n        do_rescale: plot DP-rescaled values\n        do_loglog: use log axes\n        y_sf: scale \u03c1 values by this amount\n        n_digits: number of digits to be used in title when printing linear coefficient a\n        do_label_\u0394: compute \u0394=a-a_c and label curves with it, instead of just a\n\n    Returns:\n        Matplotlib figure instance.\n\n    \"\"\"\n    fig_size: tuple[float,float] = (6, 4,)\n    fig = self.create_figure(fig_name=name, fig_size=fig_size,)\n    sim_: Any\n    parameters_list: list[dict] = [\n        sim_.parameters for sim_ in sims_list\n    ]\n    analysis_list: list[dict] = [\n        sim_.analysis for sim_ in sims_list\n    ]\n    t_epochs_list: list[NDArray] = [\n        sim_.t_epochs for sim_ in sims_list\n    ]\n    mean_densities_list: list[NDArray] = [\n        sim_.mean_densities for sim_ in sims_list\n    ]\n    title = make_sim_title(\n        parameters_list[0], analysis_list[0], dplvn, do_omit_a=True,\n    )\n    plt.title(title, fontdict={\"size\":11},)\n\n    # See Hinrichsen 2010, table 2; Henkel et al 2008, tables 4.1, 4.3\n    dp_\u03b2: float    = analysis_list[0][\"dp_\u03b2\"]\n    dp_\u03bd_pp: float = analysis_list[0][\"dp_\u03bd_pp\"]\n    dp_\u03bd_ll: float = analysis_list[0][\"dp_\u03bd_ll\"]\n    dp_\u03b4: float    = analysis_list[0][\"dp_\u03b4\"]\n    dp_z: float    = analysis_list[0][\"dp_z\"]\n\n    n_sims: int = len(sims_list)\n    color_palette: str = \"coolwarm\" #\"viridis_r\"\n    cmap: ListedColormap = mpl.colormaps[color_palette] #type: ignore\n    color_list: NDArray = cmap(np.linspace(0, 1, n_sims,))*0.75 #type: ignore\n    i_: int\n    for (i_, (\n        parameters_, analysis_, t_epochs_, mean_densities_, \n        color_\n    )) in enumerate(zip(\n        parameters_list, \n        analysis_list, \n        t_epochs_list, \n        mean_densities_list,\n        color_list[::-1],\n    )):\n        t : NDArray= t_epochs_[mean_densities_&gt;0]\n        md: NDArray = mean_densities_[mean_densities_&gt;0]\n        md = md[t&gt;=5e-1]\n        t = t[t&gt;=5e-1]\n\n        t_: NDArray\n        md_: NDArray\n        \u0394: float = parameters_[\"linear\"]-analysis_[\"a_c\"]\n        # n_x: int = parameters_[\"grid_size\"][0]\n        # n_y: int = parameters_[\"grid_size\"][1]\n        # t_ = t**(dp_\u03bd_ll)/(float(n_x*n_y))**dp_z\n        if do_rescale:\n            t_ = np.abs(\u0394) * t**(dp_\u03bd_ll)\n            md_ = md * t**(dp_\u03b2/dp_\u03bd_ll)\n        else:\n            t_ = t\n            md_ = md\n\n        if not do_rescale and np.abs(\u0394)&lt;1e-10:\n            plt.plot(\n                t_trend, md_trend*y_sf, \"k-\",  lw=2, alpha=0.4,\n                zorder=10,\n            )\n        if np.abs(\u0394)&lt;1e-10 and do_rescale:\n            continue\n\n        t_trend: NDArray \n        if do_loglog:\n            t_trend = 10**np.arange(\n                np.log10(t_[0]), max(5.0, np.log10(t_[-1]))+0.1, 0.1,\n            )\n        else:\n            t_trend = t_\n        md_trend: NDArray = (t_trend)**(-dp_\u03b4) * (md_[0])\n\n        label_: str = (\n            f\"{round(\u0394*100,n_digits-2):01.1f}\" if do_label_\u0394 \n            else f\"{parameters_[\"linear\"]:01.6f}\"\n        )\n        plt.plot(\n            t_, md_, \"-\", \n            color=color_, lw=0.5, alpha=0.7, zorder=n_sims-i_,\n        )\n        plt.plot(\n            0*t_, 0*md_, \"-\", \n            color=color_, lw=1.5, alpha=1, label=label_, zorder=n_sims-i_,\n        )\n\n    if do_rescale:\n        plt.xlabel(r\"Rescaled time $|a-a_c|^{\\nu_{||}}\\, t$  [-]\")\n        plt.ylabel(\n            r\"Rescaled grid-mean density  \"\n            + r\"$t^{\\beta/\\nu_{\\perp}}\\overline{\\rho} $  [-]\"\n        )\n        if do_loglog:\n            plt.ylim(sims_info[\"Misc\"][\"ylimits_rescaled\"])\n            plt.xlim(sims_info[\"Misc\"][\"xlimits_rescaled\"])\n        else:\n            plt.ylim(0, None,)\n            plt.xlim(1e0, None,)\n    else:\n        plt.xlabel(r\"Time $t$  [-]\")\n        plt.ylabel(r\"Grid-mean density  $\\overline{\\rho}(t)$  [-]\")\n        if do_loglog:\n            plt.ylim(sims_info[\"Misc\"][\"ylimits_log\"])\n            plt.xlim(sims_info[\"Misc\"][\"xlimits_log\"])\n        else:\n            plt.autoscale(\n                enable=True, axis='both', tight=True,\n            )\n            plt.ylim(0, None,)\n    if do_loglog:\n        plt.loglog()\n\n    plt.legend(\n        fontsize=7, \n        title=r\"$100(a-a_c)$\", title_fontsize=8,\n        loc=(\"upper left\" if do_rescale else \"lower left\"),\n    )\n    plt.grid(ls=\":\")\n    plt.close()\n    return fig\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>of figure to be used as key in viz dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(sims_info)","title":"<code>sims_info</code>","text":"(<code>dict</code>)           \u2013            <p>dictionary of ensemble</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(sims_list)","title":"<code>sims_list</code>","text":"(<code>list[Any]</code>)           \u2013            <p>list of all sim instances in the ensemble</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(do_rescale)","title":"<code>do_rescale</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>plot DP-rescaled values</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(do_loglog)","title":"<code>do_loglog</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>use log axes</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(y_sf)","title":"<code>y_sf</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>scale \u03c1 values by this amount</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(n_digits)","title":"<code>n_digits</code>","text":"(<code>int</code>, default:                   <code>6</code> )           \u2013            <p>number of digits to be used in title when printing linear coefficient a</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.multiplot_mean_density_evolution(do_label_\u0394)","title":"<code>do_label_\u0394</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>compute \u0394=a-a_c and label curves with it, instead of just a</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.naturalize","title":"naturalize","text":"<pre><code>naturalize(fig: Figure) -&gt; None\n</code></pre> <p>Adjust graph aspect ratio into 'natural' ratio.</p> Source code in <code>lvn/viz.py</code> <pre><code>def naturalize(self, fig: Figure) -&gt; None:\n    \"\"\"Adjust graph aspect ratio into 'natural' ratio.\"\"\"\n    axes: Axes = fig.gca() #type: ignore\n    # x_lim, y_lim = axes.get_xlim(), axes.get_ylim()\n    # axes.set_aspect((y_lim[1]-y_lim[0])/(x_lim[1]-x_lim[0]))\n    axes.set_aspect(1 / self.get_aspect(axes))\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image","title":"plot_density_image","text":"<pre><code>plot_density_image(\n    name: str,\n    parameters: dict,\n    analysis: dict,\n    t_epoch: float,\n    density: NDArray,\n    density_max: float = 5,\n    tick_\u0394\u03c1: float = 0.5,\n    do_extend_if_periodic: bool = False,\n    n_digits: int = 6,\n) -&gt; Figure\n</code></pre> <p>Generate an image grid of the Langevin density field.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>Matplotlib figure instance.</p> </li> </ul> Source code in <code>lvn/dp/vizdp.py</code> <pre><code>def plot_density_image(\n        self,\n        name: str, \n        parameters: dict,\n        analysis: dict,\n        t_epoch: float, \n        density: NDArray,\n        density_max: float=5,\n        tick_\u0394\u03c1: float=0.5,\n        do_extend_if_periodic: bool=False,\n        n_digits: int=6,\n    ) -&gt; Figure:\n    \"\"\"\n    Generate an image grid of the Langevin density field.\n\n    Args:\n        name: of figure to be used as key in viz dictionary\n        parameters: sim parameters dictionary\n        analysis: sim analysis dictionary\n        t_epoch: time slice of density grid\n        density: the sliced density field\n        density_max: upper bound for rendering density\n        tick_\u0394\u03c1: step in density colorbar labeling\n        do_extend_if_periodic: artificially extend grid by ~20% in periodic directions\n        n_digits: number of digits to be used in title when printing linear coefficient a\n\n    Returns:\n        Matplotlib figure instance.\n    \"\"\"\n    fig_size: tuple[float,float] = (6.5, 6.5,)\n    fig = self.create_figure(fig_name=name, fig_size=fig_size,)\n\n    prefix: str = (\n        r\"$\\rho(\\mathbf{x},t=$\" + f\"{t_epoch:0{n_digits+2}.1f}\" + r\"$)$  \"\n    )\n    title = make_sim_title(\n        parameters, analysis, dplvn,\n    )\n    plt.title(prefix+title, fontdict={\"size\":10},)\n\n    color_palette: str = \"inferno_r\"\n    color_map: Colormap = plt.get_cmap(color_palette) #type: ignore\n    grid_: NDArray = np.flipud(density.T)\n    n_pad_ud: int\n    n_pad_lr: int\n    if (\n        do_extend_if_periodic \n        and parameters[\"grid_topologies\"][0]==dplvn.PERIODIC\n    ):\n        n_pad_ud = max(grid_.shape[0]//5, 10)\n        grid_ = np.vstack([grid_, grid_[:n_pad_ud]])\n    if (\n        do_extend_if_periodic \n        and parameters[\"grid_topologies\"][1]==dplvn.PERIODIC\n    ):\n        n_pad_lr = max(grid_.shape[1]//5, 10)\n        grid_ = np.hstack([grid_, grid_[:,:n_pad_lr]])\n    (n_ud, n_lr,) = grid_.shape\n    # print((n_ud, n_lr,))\n    plt.imshow(\n        grid_,  \n        extent=(0, n_lr, 0, n_ud), \n        cmap=color_map,\n        vmin=0, vmax=density_max,\n    )\n    ticks: NDArray = np.arange(0, density_max+1, tick_\u0394\u03c1,)\n    color_bar: Any = plt.colorbar(\n        shrink=0.35, pad=0.05, aspect=12, ticks=ticks, extend=\"max\",\n    )\n    color_bar.set_label(r\"$\\rho(\\mathbf{x},t)$  [-]\")\n    plt.xlabel(r\"$x$   [-]\")\n    plt.ylabel(r\"$y$   [-]\")\n    plt.close()\n    return fig\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>of figure to be used as key in viz dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(parameters)","title":"<code>parameters</code>","text":"(<code>dict</code>)           \u2013            <p>sim parameters dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(analysis)","title":"<code>analysis</code>","text":"(<code>dict</code>)           \u2013            <p>sim analysis dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(t_epoch)","title":"<code>t_epoch</code>","text":"(<code>float</code>)           \u2013            <p>time slice of density grid</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(density)","title":"<code>density</code>","text":"(<code>NDArray</code>)           \u2013            <p>the sliced density field</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(density_max)","title":"<code>density_max</code>","text":"(<code>float</code>, default:                   <code>5</code> )           \u2013            <p>upper bound for rendering density</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(tick_\u0394\u03c1)","title":"<code>tick_\u0394\u03c1</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>step in density colorbar labeling</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(do_extend_if_periodic)","title":"<code>do_extend_if_periodic</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>artificially extend grid by ~20% in periodic directions</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_density_image(n_digits)","title":"<code>n_digits</code>","text":"(<code>int</code>, default:                   <code>6</code> )           \u2013            <p>number of digits to be used in title when printing linear coefficient a</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution","title":"plot_mean_density_evolution","text":"<pre><code>plot_mean_density_evolution(\n    name: str,\n    parameters: dict,\n    analysis: dict,\n    misc: dict,\n    t_epochs: NDArray,\n    mean_densities: NDArray,\n    do_rescale: bool = False,\n    do_loglog: bool = True,\n    y_sf: float = 1,\n    n_digits: int = 6,\n) -&gt; Figure\n</code></pre> <p>Plot a graph of the mean density \u03c1(t) versus time t.</p> <p>Depending on the arguments, the graph may plot DP-rescaled values,  and may have log-log axes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>Matplotlib figure instance.</p> </li> </ul> Source code in <code>lvn/dp/vizdp.py</code> <pre><code>def plot_mean_density_evolution(\n        self,\n        name: str, \n        parameters: dict,\n        analysis: dict,\n        misc: dict,\n        t_epochs: NDArray,\n        mean_densities: NDArray,\n        do_rescale: bool=False,\n        do_loglog: bool=True,\n        y_sf: float=1,\n        n_digits: int=6,\n    ) -&gt; Figure:\n    \"\"\"\n    Plot a graph of the mean density \u03c1(t) versus time t.\n\n    Depending on the arguments, the graph may plot DP-rescaled values, \n    and may have log-log axes.\n\n    Args:\n        name: of figure to be used as key in viz dictionary\n        parameters: sim parameters dictionary\n        analysis: sim analysis dictionary\n        misc: sim miscellaneous dictionary\n        t_epochs: time slices of simulation\n        mean_densities: grid-averaged density field during simulation\n        do_rescale: plot DP-rescaled values\n        do_loglog: use log axes\n        y_sf: scale \u03c1 values by this amount\n        n_digits: number of digits to be used in title when printing linear coefficient a\n\n    Returns:\n        Matplotlib figure instance.\n    \"\"\"\n    fig_size: tuple[float,float] = (6, 4,)\n    fig = self.create_figure(fig_name=name, fig_size=fig_size,)\n    title = make_sim_title(\n        parameters, analysis, dplvn,\n    )\n    plt.title(title, fontdict={\"size\":11},)\n\n    # See Hinrichsen 2010, table 2; Henkel et al 2008, tables 4.1, 4.3\n    dp_\u03b2: float    = analysis[\"dp_\u03b2\"]\n    dp_\u03bd_pp: float = analysis[\"dp_\u03bd_pp\"]\n    dp_\u03bd_ll: float = analysis[\"dp_\u03bd_ll\"]\n    dp_\u03b4: float    = analysis[\"dp_\u03b4\"]\n\n    t : NDArray= t_epochs[mean_densities&gt;0]\n    md: NDArray = mean_densities[mean_densities&gt;0]\n    md = md[t&gt;=5e-1]\n    t = t[t&gt;=5e-1]\n\n    t_: NDArray\n    md_: NDArray\n    \u0394_: float = np.abs(parameters[\"linear\"]-analysis[\"a_c\"])\n    \u0394: float = (\u0394_ if np.abs(\u0394_)&gt;1e-20 else 10**(-n_digits))\n    if do_rescale:\n        # print(f\"\u0394={\u0394}\")\n        t_ = \u0394 * t**(dp_\u03bd_ll)\n        md_ = md * t**(dp_\u03b2/dp_\u03bd_ll)\n        # md_ = md * t**(dp_\u03b4)\n    else:\n        t_ = t\n        md_ = md\n\n    t_trend: NDArray \n    if do_loglog:\n        t_trend = 10**np.arange(\n            np.log10(t_[0]), max(5.0, np.log10(t_[-1]))+0.1, 0.1,\n        )\n    else:\n        t_trend = t_\n    md_trend: NDArray = (t_trend)**(-dp_\u03b4) * (md_[0])\n\n    plt.plot(t_, md_, \"-\", lw=0.5,)\n    if not do_rescale:\n        plt.plot(t_trend, md_trend*y_sf, \"-\",  lw=1, alpha=0.5,)\n\n    if do_rescale:\n        plt.xlabel(r\"Rescaled time $|a-a_c|^{\\nu_{||}}\\, t$  [-]\")\n        plt.ylabel(\n            r\"Rescaled grid-mean density  \"\n            + r\"$t^{\\beta/\\nu_{\\perp}}\\overline{\\rho} $  [-]\"\n        )\n        if do_loglog:\n            plt.ylim(misc[\"ylimits_rescaled\"])\n            plt.xlim(misc[\"xlimits_rescaled\"])\n        else:\n            plt.ylim(0, None,)\n            plt.xlim(1e0, None,)\n    else:\n        plt.xlabel(r\"Time $t$  [-]\")\n        plt.ylabel(r\"Grid-mean density  $\\overline{\\rho}(t)$  [-]\")\n        if do_loglog:\n            plt.ylim(misc[\"ylimits_log\"])\n            plt.xlim(misc[\"xlimits_log\"])\n        else:\n            plt.autoscale(\n                enable=True, axis='both', tight=True,\n            )\n            plt.ylim(0, None,)\n    if do_loglog:\n        plt.loglog()\n\n    plt.grid(ls=\":\")\n    plt.close()\n    return fig\n</code></pre>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>of figure to be used as key in viz dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(parameters)","title":"<code>parameters</code>","text":"(<code>dict</code>)           \u2013            <p>sim parameters dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(analysis)","title":"<code>analysis</code>","text":"(<code>dict</code>)           \u2013            <p>sim analysis dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(misc)","title":"<code>misc</code>","text":"(<code>dict</code>)           \u2013            <p>sim miscellaneous dictionary</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(t_epochs)","title":"<code>t_epochs</code>","text":"(<code>NDArray</code>)           \u2013            <p>time slices of simulation</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(mean_densities)","title":"<code>mean_densities</code>","text":"(<code>NDArray</code>)           \u2013            <p>grid-averaged density field during simulation</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(do_rescale)","title":"<code>do_rescale</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>plot DP-rescaled values</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(do_loglog)","title":"<code>do_loglog</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>use log axes</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(y_sf)","title":"<code>y_sf</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>scale \u03c1 values by this amount</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.plot_mean_density_evolution(n_digits)","title":"<code>n_digits</code>","text":"(<code>int</code>, default:                   <code>6</code> )           \u2013            <p>number of digits to be used in title when printing linear coefficient a</p>"},{"location":"vizdp-reference/#lvn.dp.vizdp.VizDP.stretch","title":"stretch","text":"<pre><code>stretch(\n    fig: Figure,\n    xs: tuple[float, float] | None = None,\n    ys: tuple[float, float] | None = None,\n) -&gt; None\n</code></pre> <p>Stretch graph axes by respective factors.</p> Source code in <code>lvn/viz.py</code> <pre><code>def stretch(\n    self,\n    fig: Figure,\n    xs: tuple[float, float] | None = None,\n    ys: tuple[float, float] | None = None,\n) -&gt; None:\n    \"\"\"Stretch graph axes by respective factors.\"\"\"\n    axes: Axes = fig.gca() #type: ignore\n    if xs is not None:\n        x_lim = axes.get_xlim()\n        x_range = x_lim[1] - x_lim[0]\n        axes.set_xlim(\n            x_lim[0] - x_range * xs[0], x_lim[1] + x_range * xs[1]\n        )\n    if ys is not None:\n        y_lim = axes.get_ylim()\n        y_range = y_lim[1] - y_lim[0]\n        axes.set_ylim(\n            y_lim[0] - y_range * ys[0], y_lim[1] + y_range * ys[1]\n        )\n</code></pre>"}]}